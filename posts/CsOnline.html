<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络 | byxl8112</title><meta name="keywords" content="Cs"><meta name="author" content="byxl8112"><meta name="copyright" content="byxl8112"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Cs-计网">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://byxl8112.github.io/posts/CsOnline.html">
<meta property="og:site_name" content="byxl8112">
<meta property="og:description" content="Cs-计网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/cs-online.webp">
<meta property="article:published_time" content="2023-05-29T00:25:16.000Z">
<meta property="article:modified_time" content="2023-06-05T12:07:06.524Z">
<meta property="article:author" content="byxl8112">
<meta property="article:tag" content="Cs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/cs-online.webp"><link rel="shortcut icon" href="https://typora8112.oss-cn-beijing.aliyuncs.com/zzzw_8112/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221130105527.jpg"><link rel="canonical" href="https://byxl8112.github.io/posts/CsOnline"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-05 20:07:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link defer rel="stylesheet" href="/css/customm.css" ><link defer rel="stylesheet" href="https://npm.elemecdn.com/xianqi-hexo/css/icon.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link defer rel="stylesheet" href="https://npm.elemecdn.com/xianqi-hexo/css/background.css"><link defer rel="stylesheet" href="https://npm.elemecdn.com/xianqi-hexo/css/index_ee.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/zzzw_8112/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221130105527.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/cs-online.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">byxl8112</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-29T00:25:16.000Z" title="发表于 2023-05-29 08:25:16">2023-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-05T12:07:06.524Z" title="更新于 2023-06-05 20:07:06">2023-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cs/">Cs</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是Internet？"><a href="#什么是Internet？" class="headerlink" title="什么是Internet？"></a>什么是Internet？</h2><h3 id="从具体构成角度"><a href="#从具体构成角度" class="headerlink" title="从具体构成角度"></a>从具体构成角度</h3><p><strong>节点</strong></p>
<ul>
<li>主机及其以上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
<p><strong>边：通信链路</strong></p>
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul>
<p><strong>数以亿计的、互联的计算设备</strong></p>
<ul>
<li><font color="red"> <strong>主机 &#x3D; 端系统</strong></font></li>
<li>运行 <font color="red"><strong>网络应用程序</strong></font></li>
</ul>
<p><strong>通信链路</strong></p>
<ul>
<li>光纤、同轴电缆、无线电、卫星</li>
<li>传输速率 &#x3D; <font color="red"><strong>带宽（bps）</strong></font></li>
</ul>
<p><font color="red">分组交换设备：转发分组（packet）</font></p>
<ul>
<li>路由器和交换机</li>
</ul>
<p><strong>协议控制发送、接收消息</strong></p>
<ul>
<li>如：TCP、IP、HTTP、FTP、PPP</li>
</ul>
<p><font color="red"><strong>Internet：网络的网络</strong> </font></p>
<ul>
<li>松散的层次结构，互联的ISP</li>
<li>公共的Internet vs，专用intranet</li>
</ul>
<p><strong>Internet标准</strong></p>
<ul>
<li>RFC：Request for comments</li>
<li>IETF：Internet Engineering Task Force</li>
</ul>
<h3 id="从服务角度"><a href="#从服务角度" class="headerlink" title="从服务角度"></a>从服务角度</h3><p><font color="red">使用通信设施进行通信的<strong>分布式应用</strong></font></p>
<ul>
<li>Web、VoIP、email、分布式游戏、电子商务、社交网络 ……</li>
</ul>
<p><font color="red"><strong>通信基础设施为apps提供编程接口（通信服务）</strong></font></p>
<ul>
<li>将发送和接收数据的apps与互联网连接起来</li>
<li>为app应用提供服务选择，类似于邮政服务：<ul>
<li>无连接不可靠服务</li>
<li>面向连接的可靠服务</li>
</ul>
</li>
</ul>
<h3 id="什么是协议？"><a href="#什么是协议？" class="headerlink" title="什么是协议？"></a>什么是协议？</h3><p><strong>人类协议</strong></p>
<p>你好—&gt; 你好 。</p>
<p>发送特定的消息、收到消息是采取的特定行动或其他事件</p>
<p><strong>网络协议</strong></p>
<ul>
<li>类似人类协议</li>
<li>机器之间的协议而非人与人之间的协议</li>
<li>Internet中所有的通信行为都受协议制约</li>
</ul>
<blockquote>
<p>协议定义了在两个或多个通信实体之间交换的<font color="red">报文格式</font>和<font color="red">次序</font>，以及在报文传输和&#x2F;或接收或其他时间方面所采取的<font color="red">动作</font></p>
</blockquote>
<p>人类和计算机网络协议示例：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529153604981.png" alt="image-20230529153604981" style="zoom:67%;" />

<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><ul>
<li>网络边缘<ul>
<li>主机</li>
<li>应用程序（客户端和服务器）</li>
</ul>
</li>
<li>网络核心<ul>
<li>互联着的路由器</li>
<li>网络的网络</li>
</ul>
</li>
<li>接入网、物理媒体<ul>
<li>有线或者无线通信链路</li>
</ul>
</li>
</ul>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p><strong>端系统（主机）</strong></p>
<ul>
<li>运行应用程序</li>
<li>如Web、email</li>
<li>在 “网络的边缘”</li>
</ul>
<p><strong>客户&#x2F;服务器模式</strong></p>
<ul>
<li>客户端向服务器请求、接收服务</li>
<li>如Web浏览器&#x2F;服务器：email 客户端&#x2F;服务器</li>
</ul>
<p><strong>对等（peer-peer）模式</strong></p>
<ul>
<li>很少（甚至没有）专门的服务器</li>
<li>如 Gnutella、KaZaA、Emule</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230107154324733.png" alt="image-20230107154324733" style="zoom:67%;" /> 

<h3 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a>采用网络设施的面向连接服务</h3><p><font color="red"><strong>目标</strong></font>：<strong>在端系统之间传输数据</strong></p>
<p><strong>握手：在数据传输之前做好准备</strong></p>
<ul>
<li>人类协议中：你好、你好</li>
<li>两个通信主机之间为<font color="red">连接建立状态</font></li>
</ul>
<p><strong>TCP - 传输控制协议（Transmission Control Protocol）</strong> </p>
<ul>
<li>Internet上面向连接的服务</li>
</ul>
<p><font color="red"><strong>TCP服务</strong></font></p>
<ul>
<li>可靠地、按顺序地传送数据<ul>
<li>确认和重传</li>
</ul>
</li>
<li>流量控制<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>当网络拥塞时，发送方降低发送速率</li>
</ul>
</li>
</ul>
<h3 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h3><p><font color="red"><strong>目标：</strong></font>在端系统之间传输数据</p>
<ul>
<li>无连接服务</li>
</ul>
<p><font color="red"><strong>UDP</strong></font> - 用户数据报协议（User Datagram Protocol）[RFC 768]：</p>
<ul>
<li>无连接</li>
<li>不可靠数据传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
<p><font color="red"><strong>使用TCP的应用：</strong></font></p>
<ul>
<li>HTTP（Web）</li>
<li>FTP（文件传送）</li>
<li>Telnet（远程登录）</li>
<li>SMTP（email）</li>
</ul>
<p><font color="red"><strong>使用UDP的应用：</strong></font></p>
<ul>
<li>流媒体</li>
<li>远程会议</li>
<li>DNS</li>
<li>Internet电话</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心：路由器的网状网络（即由互联因特网端系统的分组交换机和链路构成的网状网络）</p>
<h3 id="数据怎样通过网络进行传输？"><a href="#数据怎样通过网络进行传输？" class="headerlink" title="数据怎样通过网络进行传输？"></a>数据怎样通过网络进行传输？</h3><p><font color="red"><strong>电路交换：</strong></font></p>
<p>为每个呼叫预留一条专有电路：如电话网</p>
<p><font color="red"><strong>分组交换：</strong></font></p>
<ul>
<li>将有传送的数据分成一个个单位：分组</li>
<li>将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力（带宽）</li>
</ul>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>在电路交换网络中，在端系统键通信会话期间，预留了端系统间沿路径通过所需要的资源（缓存、链路传输速率）</p>
<p><font color="red"><strong>端到端的资源被分配给从源端到目标端的呼叫“call”：</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230203162504963.png" alt="image-20230203162504963" style="zoom:67%;" />

<ul>
<li>图中，每段链路有4条线路：<ul>
<li>该呼叫采用了上面链路的第2个线路，右边链路的第1个线路（piece）</li>
</ul>
</li>
<li>独享资源：不同享<ul>
<li>每个呼叫一旦建立起来就能够保证性能</li>
</ul>
</li>
<li>如果呼叫没有数据发送，被分配的资源就会被浪费（no sharing）</li>
<li>通常被传统电话网络采用</li>
</ul>
<p><font color="red"><strong>为呼叫预留端—端资源</strong></font></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529174841865.png" alt="image-20230529174841865" style="zoom:50%;" /> 

<ul>
<li>链路带宽、交换能力</li>
<li>专用资源：不共享</li>
<li>保证性能</li>
<li>要求建立呼叫连接</li>
</ul>
<p>网络资源（如带宽）被分成<font color="red"><strong>片</strong></font></p>
<ul>
<li>为呼叫分配片</li>
<li>如果某个呼叫没有数据，则其资源片处于<font color="red"><strong>空闲状态</strong></font>（不共享）</li>
<li>将带宽分成片<ul>
<li>频分（Frequency-division multiplexing）</li>
<li>时分（Time-division multiplexing）</li>
<li>波分（Wave-division multiplexing）</li>
</ul>
</li>
</ul>
<p><font color="red"><strong>电路交换：FDM 与 TDM</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529175359336.png" alt="image-20230529175359336" style="zoom:67%;" />

<p><strong>计算举例：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529175505353.png" alt="image-20230529175505353" style="zoom:67%;" /> 

<p><font color="red"><strong>电路交换不适合计算机之间的通信的原因：</strong></font></p>
<ul>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多<ul>
<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
</ul>
</li>
<li>可靠性不高</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="分组交换-1"><a href="#分组交换-1" class="headerlink" title="分组交换"></a>分组交换</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529180034703.png" alt="image-20230529180034703" style="zoom:67%;" />

<p><font color="red"><strong>以分组为单位存储—转发方式</strong></font></p>
<ul>
<li>网络带宽资源不再分为一个个片，传输时使用全部带宽</li>
<li>主机之间传输的数据被分为一个个分组</li>
</ul>
<p><font color="red"><strong>资源共享，按需使用：</strong></font></p>
<ul>
<li>存储-转发：分组每次移动一跳（hop）<ul>
<li>转发之前，节点必须收到整个分组</li>
<li>延迟比线路交换要大</li>
<li>排队时间</li>
</ul>
</li>
</ul>
<p>在源和目的地之间，每个分组都通过通信链路和分组交换机传送，交换机主要有路由器和链路层交换机两类，分组以等于该链路最大传输速率的速度通过通信链路。</p>
<h4 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a>统计多路复用</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529180525266.png" alt="image-20230529180525266" style="zoom:67%;" />

<p>A&amp;B 时分复用   链路资源</p>
<p>A&amp;B 分组没有固定的模式 -&gt; <font color="red">统计多路复用</font></p>
<h4 id="网络核心的关键功能"><a href="#网络核心的关键功能" class="headerlink" title="网络核心的关键功能"></a>网络核心的关键功能</h4><p><strong>存储-转发</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230203191846192.png" alt="image-20230203191846192" style="zoom:67%;" />

<ul>
<li>被传输到下一个链路之前，整个分组必须到达路由器：<font color="red">存储-转发</font></li>
<li>在一个速率为 <strong>R bps</strong> 的链路，一个长度为 <strong>L bits</strong> 的分组的存储转发延时： <strong>L&#x2F;R s</strong></li>
</ul>
<blockquote>
<p>例如：</p>
<p>L &#x3D; 7.5 Mbits</p>
<p>R &#x3D; 1.5Mbps</p>
<p>3次存储转发的延时 &#x3D; 15 s</p>
</blockquote>
<p><font color="red"><strong>分组交换：</strong></font>分组的存储转发一段一段从源端传到目标端，按照有无网络层的连接，分成：</p>
<ul>
<li>数据报网络：<ul>
<li>分组的目标地址决定下一跳</li>
<li>在不同的阶段，路由可以改变</li>
<li>类似：问路</li>
<li>Internet</li>
</ul>
</li>
<li>虚电路网络：<ul>
<li>每个分组都带标签（虚电路标识 VCID），标签决定下一跳</li>
<li>在 <font color="red"><strong>呼叫建立时</strong></font> 决定路径，在整个呼叫中路径保持不变</li>
<li><font color="red"><strong>路由器维持每个呼叫的状态信息</strong></font></li>
<li>X.25和ATM</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529183147010.png" alt="image-20230529183147010" style="zoom:67%;" />

<p>数据报的工作原理</p>
<ul>
<li>在通信之前，无需建立一个连接，有数据就传输</li>
<li>每一个分组都独立路由（路径不一样，可能会失序）</li>
<li>路由器 根据分组的目标地址进行路由</li>
</ul>
<p>虚电路（virtual circuit）的工作原理</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529202119504.png" alt="image-20230529202119504" style="zoom:67%;" />

<h4 id="排队延迟和丢失"><a href="#排队延迟和丢失" class="headerlink" title="排队延迟和丢失"></a>排队延迟和丢失</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529182700070.png" alt="image-20230529182700070" style="zoom:67%;" />

<p><font color="red"><strong>排队和延迟：</strong></font></p>
<p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer，也称为输出队列（output queue）），它用于存储器准备发往哪条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延外，分组还要承受输出缓存的<strong>排队时延</strong>（queuing delay）。这些时延是变化的，变化的程度取决于<strong>网络的拥塞程度</strong>。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现<font color="red"><strong>分组丢失（丢包）</strong></font>(packet loss)，到达的分组或已经排队的分组之一将被丢弃。</p>
<p>如果到达速率 &gt; 链路的输出速率：</p>
<ul>
<li>分组将会排队，等待传输</li>
<li>如果路由器的缓存用完了，分组将会被抛弃</li>
</ul>
<p>转发表和路由选择协议：</p>
<p><font color="red"><strong>路由：</strong></font>决定分组采用的源到目标的路径</p>
<p><font color="red"><strong>转发：</strong></font>将分组从路由器的输入链路转移到输出链路</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529192510844.png" alt="image-20230529192510844" style="zoom:67%;" />

<p>在因特网中，每个端系统具有一个称为IP地址的地址。当源主机要向目标主机，要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址，如同 邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器是，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。特别的是，每台路由器具有一个 <strong>转发表</strong>（forwarding table），用于将目的地址（或者目的地址的一部分）映射称为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个地址搜索其转发表，以发现适当的输出链路。路由器则将分组导向该输出链路。</p>
<p>以上解释了 路由器使用的分组的目的地址来索引转发表并决定适当的出链路。但是 转发表是如何进行设置的呢？</p>
<p>因特网具有一些特殊的 <strong>路由选择协议</strong>（routing protocol），用于自动地设置这些转发表。</p>
<p>例如：一个路由选择协议 可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径的结果来配置 路由器中的转发表。</p>
<h3 id="电路交换-VS-分组交换"><a href="#电路交换-VS-分组交换" class="headerlink" title="电路交换 VS 分组交换"></a>电路交换 VS 分组交换</h3><p>分组交换的性能优于电路交换的性能</p>
<p><font color="red"><strong>同样的网络资源，分组交换允许更多用户使用网络</strong></font></p>
<ul>
<li>1 Mb&#x2F;s 链路</li>
<li>每个用户：<ul>
<li>活动时  100 kb&#x2F;s</li>
<li>10% 的时间是活动的</li>
</ul>
</li>
<li>电路交换：<ul>
<li>10 用户</li>
</ul>
</li>
<li>分组交换：<ul>
<li>35 用户时</li>
<li><code>&gt;= 10</code> 个用户活动的概率为  0.0004</li>
</ul>
</li>
</ul>
<p><font color="red"><strong>分组交换是 ”突发数据的胜利者？“</strong></font></p>
<ul>
<li>适合于对突发式数据传输<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li><font color="red"><strong>过度使用会造成网络拥塞：</strong></font>分组延时和丢失<ul>
<li>对可靠地传输需要协议来约束：拥塞控制</li>
</ul>
</li>
<li><font color='red'><strong>怎样提供 类似电路交换的服务？</strong></font>
* 保证音频/视频应用需要的带宽
* 一个 仍未解决的问题（chapter 7）</li>
</ul>
<h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230203201803329.png" alt="image-20230203201803329" style="zoom:67%;" />

<h2 id="接入网络和物理媒体"><a href="#接入网络和物理媒体" class="headerlink" title="接入网络和物理媒体"></a>接入网络和物理媒体</h2><p><font color='red'><strong>怎样将端系统和边缘路由器连接？</strong><br></font></p>
<ul>
<li>住宅接入网络</li>
<li>单位接入网络（学校、公司）</li>
<li>无线接入网络</li>
</ul>
<p><font color='red'><strong>注意：</strong><br></font></p>
<ul>
<li>接入网络的带宽（bits per second） ?</li>
<li>共享&#x2F;专用？</li>
</ul>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>考虑了位于 ”网络边缘“ 的应用程序 和 法人系统后，下面考虑 <strong>接入网</strong>，这是指将端系统物理连接到其 <strong>边缘路由器</strong>（edge route）的网络</p>
<p><strong>边缘路由器</strong>是指 端系统到任何其他远程端系统的路径上的第一台路由器</p>
<h4 id="住宅接入：modem"><a href="#住宅接入：modem" class="headerlink" title="住宅接入：modem"></a>住宅接入：modem</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230529203052361.png" alt="image-20230529203052361" style="zoom:67%;" /> 

<ul>
<li>将上网数据<font color='red'><strong>调制</strong></font>加载音频信号上，在电话线上传输，在局端将其中的数据<font color='red'><strong>解调</strong></font>出来；反之亦然<ul>
<li>调频</li>
<li>调幅</li>
<li>调相位</li>
<li>综合调制</li>
</ul>
</li>
<li><font color='red'><strong>拨号调制解调器</strong></font><ul>
<li>56 Kbps 的速率直接接入路由器（通常更低）</li>
<li>不能同时上网和打电话：不能总是在线</li>
</ul>
</li>
</ul>
<p>住宅接入：线缆模式</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230204195618627.png" alt="image-20230204195618627" style="zoom:67%;" />

<h4 id="数字用户线"><a href="#数字用户线" class="headerlink" title="数字用户线"></a>数字用户线</h4><p>数字用户线（digital subscriber line (DSL)）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230204194436253.png" alt="image-20230204194436253" style="zoom:67%;" />

<ul>
<li>采用 <strong>现存的</strong> 到交换局 DSLAM（数字用户线接入复用器）的电话线<ul>
<li>DSL 线路上的数据被传到互联网</li>
<li>DSL 线路上的语音被传到电话网</li>
</ul>
</li>
<li>&lt; 2.5 Mbps 上行传输速率（typical &lt; 1 Mbps）</li>
<li>&lt; 24 Mbps  下行传输速率 （typical &lt; 10 Mbps）</li>
</ul>
<h4 id="线缆网络"><a href="#线缆网络" class="headerlink" title="线缆网络"></a>线缆网络</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230204194808592.png" alt="image-20230204194808592" style="zoom:67%;" />

<p>有线电视信号线缆双向改造</p>
<p><font color='red'><strong>FDM：</strong></font>（频分复用）在 不同频段传输不同信道的数据，数字电视和 上网数据（上下行）</p>
<p>将 <strong>整个带宽（频率）</strong>分成多个频带，用户在通信过程中 始终 占用这个频带。</p>
<p>频分复用的所有用户在同一时间占用不同的带宽资源（频率）</p>
<p><strong>频分复用</strong>是一种模拟技术，以链路带宽（以Hz为单位）大于要传输的信号的带宽之和时采用。</p>
<p><strong>防护频带</strong>是指在通道之间狭长未被使用的带宽，这部分用来隔离信号，防止信号重叠</p>
<blockquote>
<p>复用过程：</p>
<ol>
<li>将信号调制到不同频率的载波上</li>
<li>将调制过的模拟信号叠加成复合信号</li>
<li>通过足够带宽的介质发送出去</li>
</ol>
<p>复用分离过程：</p>
<ol>
<li>使用滤波器将复合信号分解成组成它的各个信号</li>
<li>使用解调器，将信号还原</li>
</ol>
</blockquote>
<p><font color='red'><strong>TDM：</strong></font>（时分复用）所有参与复用的用户在 不同的时间 占用 相同的频带宽度</p>
<p>时分复用是一个数字化过程，它允许多个连接共享一条高带宽链路</p>
<p>TDM是组合多个低俗通道为一个高速通道数据的复用技术</p>
<blockquote>
<p>时隙和帧：</p>
<p>时隙：指的是一段时间，在这段时间内，某些网络设备或节点可以发送或接收数据。时隙通常由网络协议或协议栈中的某个组件分配或管理。时隙的长度可以是固定的，也可以是可变的，取决于网络协议或协议栈的设计。</p>
<p>帧：计算机网络中数据传输的基本单位。它包括了数据和一些必要的控制信息，如数据类型、原地址、目标地址、校验和等等。帧通常是由物理层或数据链路层协议定义的，以便在网络中传输数据。帧的长度也可以是固定的或可变的，取决于协议的设计。</p>
</blockquote>
<p><font color='red'><strong>FDM和TDM的优缺点</strong></font></p>
<blockquote>
<p>FDM（Frequency Division Multiplexing，频分复用）和TDM（Time Division Multiplexing，时分复用）都是多路复用技术，用于将多个信号合并在一条通信线路上进行传输。它们各自具有优点和缺点：</p>
<p>FDM的优点：</p>
<ol>
<li>可以同时传输多个信号，且信号彼此独立，不会相互干扰。</li>
<li>在不同的频带上分配不同的信号，可以避免不同信号之间的干扰。</li>
<li>FDM技术已经得到广泛的应用，在广播、电视、电话和计算机网络等领域都有应用。</li>
</ol>
<p>FDM的缺点：</p>
<ol>
<li>频带宽度有限，需要有足够的频带宽度才能支持多个信号的传输。</li>
<li>频带的利用率不高，因为不同信号之间的频带可能会有空闲，但不能用于传输其他信号。</li>
</ol>
<p>TDM的优点：</p>
<ol>
<li>可以使用相同的通信线路传输多个信号，提高了通信线路的利用率。</li>
<li>通过时间片的方式分配信号传输时间，可以避免不同信号之间的干扰。</li>
<li>TDM技术具有较高的灵活性，可以根据需要调整不同信号的传输速率和优先级。</li>
</ol>
<p>TDM的缺点：</p>
<ol>
<li>对于传输速率较高的信号，需要分配更多的时间片，可能会导致其他信号的传输受到影响。</li>
<li>在传输过程中，如果某个信号的数据量过大，可能会导致其他信号的传输延迟。</li>
</ol>
<p>总的来说，FDM适用于需要传输的信号数量较少且带宽较大的情况，而TDM适用于需要传输的信号数量较多且带宽较小的情况。在实际应用中，FDM和TDM也可以结合使用，以充分利用通信线路的带宽资源。</p>
</blockquote>
<h4 id="家庭网络"><a href="#家庭网络" class="headerlink" title="家庭网络"></a>家庭网络</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230530210013440.png" alt="image-20230530210013440" style="zoom:67%;" />

<h4 id="企业接入网络"><a href="#企业接入网络" class="headerlink" title="企业接入网络"></a>企业接入网络</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230530210052010.png" alt="image-20230530210052010" style="zoom:67%;" />

<ul>
<li>经常被企业或者大学等机构采用<ul>
<li>10 Mbps，100 Mbps，1 Gbps，10 Gbps 传输率</li>
<li>现在，端系统经常直接接到以太网络交换机上</li>
</ul>
</li>
</ul>
<h4 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h4><p>各无线端系统共享无线接入网络（端系统到无线路由器）</p>
<ul>
<li>通过基站或者叫接入点</li>
</ul>
<p><font color='red'><strong>无线LANs：</strong></font></p>
<ul>
<li>建筑物内部（100 ft）</li>
<li>802.11 b&#x2F;g（WiFi）：11，54 Mbps 传输速率</li>
</ul>
<p><font color='red'><strong>广域无线接入：</strong></font></p>
<ul>
<li>由电信运营商提供（cellular），10‘  s km</li>
<li>1 到 10 Mbps</li>
<li>3G，4G：LTE</li>
</ul>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><font color='red'><strong>Bit：</strong></font>在发送-接收对间传播</p>
<p><font color='red'><strong>物理链路：</strong></font>连接每个发送-接收对之间的物理媒体</p>
<p><font color='red'><strong>导引型媒体：</strong></font></p>
<ul>
<li>信号沿着固体媒介被导引：同轴电缆、光纤、双绞线</li>
</ul>
<p><font color='red'><strong>非导引型媒体：</strong></font></p>
<ul>
<li>开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li>
</ul>
<p><font color='red'><strong>双绞线（TP）</strong></font></p>
<ul>
<li><p>两根绝缘铜导线拧合</p>
<ul>
<li>5类：100 Mbps 以太网，Gbps千兆以太网</li>
<li>6类：10Gbps 万兆以太网</li>
</ul>
</li>
<li><p>无屏蔽双绞线（UTP）</p>
<ul>
<li>常用在建筑物内的计算机网络中（即局域网）</li>
<li>目前局域网中双绞线的数据速率为 10 Mbps 到 10Gbps，所能达到的数据传输速率取决于导线线径以及传输方和接收方之间的距离</li>
</ul>
</li>
<li><p>DSL技术通过双绞线使住宅用户以超过数十 Mbps的速率接入因特网</p>
<blockquote>
<p>关于DSL技术，DSL是“数字用户线”（Digital Subscriber Line）的缩写，它是一种基于电话线传输数据的技术，可以实现高速的互联网接入。DSL技术通过利用电话线的高频段传输数据，从而实现高速的数据传输。</p>
<p>DSL技术有多种类型，其中最常见的是ADSL和VDSL。ADSL是“异步数字用户线”（Asymmetric Digital Subscriber Line）的缩写，它可以实现下行速度较快、上行速度较慢的传输方式。VDSL是“高速数字用户线”（Very-high-bit-rate Digital Subscriber Line）的缩写，它可以实现更高的传输速度，同时也具有更高的成本。</p>
<p>DSL技术具有以下优点：</p>
<ol>
<li><p>高速传输：DSL技术可以实现高速的数据传输，比传统的拨号上网方式要快得多。</p>
</li>
<li><p>实现网络和电话同时使用：DSL技术可以同时使用电话和网络，不会相互干扰。</p>
</li>
<li><p>稳定性较高：DSL技术的稳定性较高，因为它使用的是电话线这样的传输介质，信号不容易受到干扰。</p>
</li>
<li><p>不受距离限制：DSL技术不受距离限制，可以通过电话线在较远的距离内传输数据。</p>
</li>
<li><p>支持多种应用：DSL技术可以支持多种应用，包括互联网接入、视频流媒体、VoIP电话等。</p>
</li>
</ol>
<p>尽管DSL技术有着许多优点，但它也有一些缺点。例如，DSL技术的传输速度和稳定性受到传输距离、线路质量和网络拥塞等因素的影响。此外，DSL技术的传输速度和稳定性也比不上光纤等其他传输介质。</p>
<p>总之，DSL技术是一种基于电话线传输数据的技术，可以实现高速的互联网接入。它具有高速传输、实现网络和电话同时使用、稳定性较高、不受距离限制和支持多种应用等优点，但也有一些缺点。</p>
</blockquote>
</li>
</ul>
<h4 id="同轴电缆、光纤"><a href="#同轴电缆、光纤" class="headerlink" title="同轴电缆、光纤"></a>同轴电缆、光纤</h4><p><font color='red'><strong>同轴电缆：</strong></font></p>
<ul>
<li>两根同轴的铜导线</li>
<li>双向</li>
<li>基带电缆<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆<ul>
<li>电缆上由多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>光纤和光缆：</strong></font></p>
<ul>
<li>光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输</li>
<li>高速：<ul>
<li>点到点的高速传输（如 10 Gps - 100 Gbps 传输速率）</li>
</ul>
</li>
<li>低误码率：在两个中继器之间可以由很长的距离，不受电磁噪声的干扰</li>
<li>安全</li>
</ul>
<h4 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h4><ul>
<li>开放空间传输电磁波，携带要传输的数据</li>
<li>无需物理 “线缆”</li>
<li>双向</li>
<li>传播环境效应：<ul>
<li>反射</li>
<li>吸收</li>
<li>干扰</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>无线链路类型：</strong></font></p>
<ul>
<li>地面微波<ul>
<li>e.g. up to 45 Mbps channels</li>
</ul>
</li>
<li>LAN (e.g.，WiFi)<ul>
<li>11 Mbps，54 Mbps，540Mbps …..</li>
</ul>
</li>
<li>wide-area （e.g.，蜂窝）<ul>
<li>3G cellular：~几Mbps</li>
<li>4G 10Mbps</li>
<li>5G 数Gbps</li>
</ul>
</li>
<li>卫星<ul>
<li>每个信道 Kbps 到 45Mbps（或者多个聚集信道）</li>
<li>270 msec端到端延迟</li>
<li>同步精致卫星和地轨卫星</li>
</ul>
</li>
</ul>
<h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><ul>
<li>端系统通过<font color='red'><strong>接入ISP</strong></font>（Internet Service Providers）连接到互联网<ul>
<li>该接入ISP能够提供有线或无线连接，使用了DSL、电缆、FTTH（光纤到户）、WiFi和蜂窝等多种技术</li>
<li>住宅，公司和大学的ISP</li>
</ul>
</li>
<li>接入ISPs相应的必须是互联的<ul>
<li>因此任何2个端系统可相互发送分组到对方</li>
</ul>
</li>
<li>导致的 “网络的网络” 非常复杂<ul>
<li>发展和演化是通过<font color='red'><strong>经济的</strong></font>和国家的政策来驱动的</li>
</ul>
</li>
<li>让我们采用渐进方法来描述当前互联网的结构</li>
</ul>
<ul>
<li>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、但是之间有着多重连接）<ul>
<li><strong>“ tier-1” commercial ISPs</strong> ,国家或者国际范围的覆盖</li>
<li><strong>content provider network</strong> : 将他们的数据中心接入 ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层 ISP 和</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>竞争：</strong></font>但如果全局ISP是有利可为的业务，那会有竞争者</p>
<p><font color='red'><strong>合作：</strong></font>通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230530220257933.png" alt="image-20230530220257933" style="zoom:67%;" />

<blockquote>
<p>ISP是“互联网服务提供商”（Internet Service Provider）的缩写，它是为用户提供互联网接入服务的企业或组织。ISP通常提供互联网接入、电子邮件、网站托管和虚拟主机等服务。</p>
<p>ISP可以分为两种类型：一种是接入ISP，它为用户提供互联网接入服务；另一种是内容ISP，它为用户提供互联网上的内容和服务。接入ISP是用户接入互联网的关键，因为它提供了用户接入互联网的技术和设备。</p>
<p>ISP通常提供多种互联网接入方式，包括拨号上网、DSL、光纤、卫星、无线等。用户可以根据自己的需要和预算选择合适的接入方式。在选择ISP时，用户需要考虑ISP提供的服务、价格、服务质量、技术支持等方面的因素。</p>
<p>ISP需要遵守法律和规定，包括网络安全、用户隐私、版权保护等方面的规定。ISP还需要保护网络的安全和稳定性，防止网络攻击和滥用。</p>
<p>总之，ISP是为用户提供互联网接入服务的企业或组织，它提供多种互联网接入方式和其他服务。在选择ISP时，用户需要考虑服务、价格、服务质量、技术支持等方面的因素。</p>
</blockquote>
<h3 id="network-of-network"><a href="#network-of-network" class="headerlink" title="network of network"></a>network of network</h3><p>松散的层次模型</p>
<p><font color='red'><strong>中心：第一层ISP</strong></font>（如UUNet，BBN&#x2F;Genuity，Sprint，AT&amp;T）国家&#x2F;国际覆盖，速率极高</p>
<ul>
<li>直接与其他第一层ISP相连</li>
<li>与大量的第二层ISP和其他客户网络相连</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531082822048.png" alt="image-20230531082822048" style="zoom:67%;" />

<p><font color='red'><strong>第二层ISP：更小些的（通常是区域性的）ISP</strong></font></p>
<ul>
<li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531082948314.png" alt="image-20230531082948314" style="zoom:67%;" />

<p><font color='red'><strong>第三层ISP与其他本地ISP</strong></font></p>
<ul>
<li>接入网（与端系统最近）</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531083045179.png" alt="image-20230531083045179" style="zoom:67%;" />

<p><font color='red'><strong>一个分组要经过许多网络！</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531083121625.png" alt="image-20230531083121625" style="zoom:67%;" />

<ul>
<li>许多内容提供商（如 Google） 可能会部署自己的网络，连接自己在各地的 DC （数据中心），走自己的数据</li>
<li>连接若干 local ISP 和各级（包括一层）ISP，更加靠近用户</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531083208757.png" alt="image-20230531083208757" style="zoom:67%;" />

<h3 id="ISP之间的连接"><a href="#ISP之间的连接" class="headerlink" title="ISP之间的连接"></a>ISP之间的连接</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531083404062.png" alt="image-20230531083404062" style="zoom:67%;" />

<p><strong>POP：</strong>（Point of Presence）存在点，高层ISP面向客户网络的接入点，涉及费用结算</p>
<ul>
<li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li>
</ul>
<p>对等接入：2个ISP对等互接，不涉及费用结算</p>
<p><strong>IXP：</strong>（因特网交换点）多个对等 ISP 互联互通之外，通常不涉及费用结算</p>
<ul>
<li>对等接入，IXP是一个汇合点，多个ISP能够在这里一起对等</li>
</ul>
<p>ICP 自己部署专用网络，同时和各级ISP连接</p>
<h3 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h3><p>可将因特网看成一种基础设施，该基础设施为运行在端系统上的分布式应用提供服务。</p>
<p>在理想情况下，我们希望因特网服务能够在热议两个端系统之间随心所欲地瞬间移动数据而没有任何数据丢失。然而这是一个极高的目标，实践中难以达到。与之相反，<strong>计算机网络必定要显示在端系统之间的吞吐量（每秒能够传送的数据量）</strong>，<strong>还会在端系统之间引入时延</strong>，而且实际上也会<strong>丢失分组</strong>。</p>
<p>在路由器缓冲区的分组队列</p>
<ul>
<li><font color='red'><strong>分组到达链路的速率超过了链路输出的能力</strong></font></li>
<li>分组等待排到队头、被传输</li>
</ul>
<h4 id="四种分组时延"><a href="#四种分组时延" class="headerlink" title="四种分组时延"></a>四种分组时延</h4><p>分组从一个主机（host 源）出发，通过一系列的路由器传输，在另一台主机（目的地）中结束它的历程。当分组从一个节点（主机或路由器）沿着这条路径到后继节点（主机或路由器），该分组在沿途的每个节点经受了几种不同类型的时延。这些时延最为重要的是</p>
<ul>
<li>节点处理时延（nodal processing delay ）</li>
<li>排队时延（queuing delay）</li>
<li>传输时延（transmission delay）</li>
<li>传播时延（propagation delay）</li>
</ul>
<p>这些时延总体累加起来是 <strong>节点总时延</strong></p>
<ul>
<li><p><font color='red'><strong>节点处理时延</strong></font></p>
<ul>
<li>检查 bit 级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
</li>
<li><p><font color='red'><strong>排队时延</strong></font></p>
<ul>
<li>在输出链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
<p>通常，到达队列的过程是随机的，即到达并不遵循任何模式，分组之间的时间间隔是随机的。</p>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531085317205.png" alt="image-20230531085317205" style="zoom:67%;" />

<ul>
<li><font color='red'><strong>传输时延</strong></font><ul>
<li>R &#x3D; 链路带宽（bps）</li>
<li>L &#x3D; 分组长度（bits）</li>
<li>将分组发送到链路上的时间 &#x3D; L &#x2F; R</li>
<li>存储转发延时</li>
</ul>
</li>
<li><font color='red'><strong>传播时延</strong></font><ul>
<li>d &#x3D; 物理链路的长度</li>
<li>s &#x3D; 在媒体上的传播速度（~2x10^8  m&#x2F;sec）</li>
<li>传播延时 &#x3D; d &#x2F; s</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531085545171.png" alt="image-20230531085545171" style="zoom:67%;" />

<p><strong>传输时延和传播时延</strong></p>
<ul>
<li>传输时延是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。</li>
<li>传播时延是一个bit从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，与分组长度或链路传输速率无关。</li>
</ul>
<blockquote>
<p>传输时延和传播时延是计算机网络中的两个重要概念，它们是评估网络性能的重要指标之一。</p>
<p>传输时延是指数据从发送端到接收端所需的时间。传输时延由数据包的大小和网络带宽决定，其计算公式为传输时延&#x3D;数据包大小 ÷ 带宽。</p>
<p>传播时延是指数据从发送端到接收端所需的时间，主要由信号在传输介质中传播所需的时间决定。传播时延由传输介质的长度和传播速度决定，其计算公式为传播时延&#x3D;传输介质长度 ÷ 传播速度。</p>
<p>在实际应用中，传输时延和传播时延都会影响网络性能。传输时延越小，网络传输速度越快，用户体验越好。传播时延越小，网络响应速度越快，用户体验也越好。因此，网络管理员需要在设计和优化网络时，尽可能减小传输时延和传播时延，以提高网络性能和用户体验。</p>
<p>除了传输时延和传播时延，网络还受到了其他因素的影响，例如网络拥塞、路由器和交换机的性能等。网络管理员需要全面地考虑这些因素，以保证网络的高性能和稳定性。</p>
<p>总之，传输时延和传播时延是计算机网络中的两个重要概念，它们是评估网络性能的重要指标之一。网络管理员需要全面考虑网络的各种因素，以优化网络性能和提高用户体验。</p>
</blockquote>
<p>时延的类型</p>
<p>作为源和目的地之间的端到端路由的一部分，一个分组从上游节点通过路由器 A 向路由器B 发送。A 具有 通往 B 的出链路。该链路 前面有一个 <strong>队列 （也称缓存）</strong>。当 分组从上游节点到达路由器 A 时，路由器 A 检查该分组的首部以决定它的适当 出链路，并将该分组导向该链路。</p>
<p>在此例子中，对该分组的出链路是通向路由器 B 的那条链路。 仅当 <strong>在该链路没有其他分组正在传输并且没有其他分组排队在该队列之前时</strong>，才能在该链路上传输该分组</p>
<p>如果 该链路当前正繁忙或有其他分组已经在该链路上排队，则 <strong>新到达的分组将加入排队</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/4e14dab0f793cc46ca1634452854643.jpg" alt="4e14dab0f793cc46ca1634452854643" style="zoom: 50%;" /> 

<h4 id="排队延时"><a href="#排队延时" class="headerlink" title="排队延时"></a>排队延时</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531092408920.png" alt="image-20230531092408920" style="zoom:50%;" />

<p>R &#x3D; 链路带宽（bps）</p>
<p>L &#x3D; 分组长度（bits）</p>
<p>a &#x3D; 分组到达队列的平均速率</p>
<p><font color='red'><strong>流量强度 &#x3D; La &#x2F; R</strong></font></p>
<ul>
<li><p>La &#x2F; R  ~ 0  ：平均排队延时很小</p>
</li>
<li><p>La &#x2F; R -&gt;1  ：延时变得很大</p>
</li>
<li><p>La &#x2F; R &gt; 1 ：比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大！</p>
</li>
</ul>
<p><font color='red'><strong>设计系统时流量强度不能大于1</strong></font></p>
<h4 id="Internet的延时和路由"><a href="#Internet的延时和路由" class="headerlink" title="Internet的延时和路由"></a>Internet的延时和路由</h4><p><font color='red'><strong>Traceroute 诊断程序：</strong></font>提供从源端，经过路由器，到目的的延时测量</p>
<ul>
<li>For all i：<ul>
<li>沿着目的的路径，向每个路由器发送3个探测分组</li>
<li>路由器 i 将向发送方返回一个分组</li>
<li>发送方对发送和回复之间间隔计时</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531092724063.png" alt="image-20230531092724063" style="zoom:50%;" />

<blockquote>
<p>traceroute是一种用于确定数据包在互联网上的路径的网络诊断工具。它通过向目标主机发送数据包，并记录经过的路由器的IP地址，从而确定数据包在互联网上的路径。</p>
<p>在使用traceroute工具时，用户需要指定目标主机的IP地址或域名。traceroute会向目标主机发送一系列数据包，并记录每个数据包通过的路由器的IP地址和响应时间。通过这些信息，用户可以了解数据包在互联网上的路径，以及每个路由器的响应时间。</p>
<p>在使用traceroute工具时，需要注意以下几点：</p>
<ol>
<li><p>需要有足够的权限：在某些操作系统中，使用traceroute需要有足够的权限，例如管理员权限。</p>
</li>
<li><p>数据包丢失和延迟：因为互联网上的路由器和服务器数量众多，数据包在传输过程中可能会出现丢失或延迟的情况。因此，在使用traceroute时，用户需要考虑这些因素。</p>
</li>
<li><p>防火墙和安全设置：某些防火墙和安全设置可能会阻止traceroute的操作，因此在使用traceroute时，需要确保网络设置合适并且没有阻止traceroute的操作。</p>
</li>
</ol>
<p>在实际应用中，traceroute工具通常用于网络故障排除和优化。例如，当用户遇到互联网连接问题时，可以使用traceroute工具来确定连接问题的具体原因，以便更好地解决问题。此外，traceroute工具还可以帮助网络管理员优化网络路由，提高网络响应速度和性能。</p>
<p>总之，traceroute是一种用于确定数据包在互联网上的路径的网络诊断工具。它通过向目标主机发送数据包，并记录经过的路由器的IP地址，从而确定数据包在互联网上的路径。</p>
</blockquote>
<h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><p>在现实中，一条链路前的队列只有有限的容量，尽管排队容量极大地依赖于路由器设计和成本。因为该排队容量是有限的，随着流量强度接近1，排队时延并不真正趋向无穷大。相反，到达的分组将发现一个满队列。由于没有地方存储这个分组，路由器将<strong>丢弃</strong>该分组，即丢包。</p>
<p>上述丢包现象看起来是一个分组已经传输到网络核心，但它绝不会从网络发送到目的地。分组丢失的比例随着流量强度增加而增加。</p>
<p>因此，一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量。</p>
<ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或者根本不重传</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531093225183.png" alt="image-20230531093225183" style="zoom:67%;" /> 

<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>在源端和目标端之间传输的速率（数据量&#x2F;单位时间）</p>
<ul>
<li><font color='red'><strong>瞬时吞吐量：</strong></font>在一个时间点的速率</li>
<li><font color='red'><strong>平均吞吐量：</strong></font>在一个长时间内平均值</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531114811924.png" alt="image-20230531114811924" style="zoom:67%;" />

<p>吞吐量取决于数据流过的链路的传输速率。我们看到当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率。</p>
<p>吞吐量不仅取决于沿着路径的传输速率，而是取决于干扰流量。特别是，如果许多其他的数据流也通过这条链路流动，一条具有高传输速率的链路仍然可能成为文件传输的瓶颈链路。</p>
<blockquote>
<p>吞吐量是计算机网络中的一个重要概念，它指的是在单位时间内通过网络传输的数据量。吞吐量是评估网络性能的一个重要指标之一，通常用于评估网络的数据传输速度。</p>
<p>在计算机网络中，吞吐量可以通过不同的方式来衡量。例如，可以通过数据包数量、数据字节数量、传输速率等方式来衡量。通常，吞吐量越大，表示网络传输速度越快，数据传输效率越高。</p>
<p>吞吐量受到多种因素的影响，例如网络带宽、传输介质、网络拥塞等。网络管理员需要全面考虑这些因素，以优化网络性能和提高吞吐量。</p>
<p>在实际应用中，吞吐量通常用于评估网络的性能和优化网络的性能。例如，在设计和优化网络时，网络管理员可以通过增加带宽、采用更快的传输介质、优化路由等方式，来提高网络的吞吐量。此外，在进行网络压力测试时，也会使用吞吐量来评估网络的性能。</p>
<p>总之，吞吐量是计算机网络中的一个重要概念，它指的是在单位时间内通过网络传输的数据量。吞吐量是评估网络性能的一个重要指标之一，通常用于评估网络的数据传输速度。</p>
</blockquote>
<h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h3><p><font color='red'><strong>网络是一个复杂的系统</strong></font></p>
<p>网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等</p>
<p>现实来看，网络的许多构成元素和设备：</p>
<ul>
<li>主机</li>
<li>路由器</li>
<li>各种媒体的链路</li>
<li>应用</li>
<li>协议</li>
<li>硬件，软件</li>
</ul>
<p><font color='red'><strong>层次化方式实现复杂网络功能：</strong></font></p>
<ul>
<li>将网络复杂的功能分成功能明确的层次，每一层实现其中一个或一组<font color='red'>功能</font>，功能中有其上层可以使用的功能：<font color='red'><strong>服务</strong></font></li>
<li>本层协议实体相互交互执行本层的<font color='red'><strong>协议动作</strong></font>，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接<font color='red'>利用了下层所提供的服务</font></li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的） + 更下层所提供的服务</li>
<li>只要该层对其上面的层提供相同的服务，并且使用来自下面的层的相同服务，当某层的实现变化时，该系统的剩余部分就可以保持不变。</li>
</ul>
<p>对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他组件是分层的一个重要优点。</p>
<p><font color='red'><strong>潜在缺点：</strong></font></p>
<ul>
<li>一层可能冗余较低层的功能<ul>
<li>例如：许多协议栈在基于每段链路和基于端到端两种情况下，都提供了差错恢复。</li>
</ul>
</li>
<li>某层的功能可能需要仅在其他某层才出现的信息（如时间戳值），这违反了层次分离的目标。</li>
</ul>
<p><font color='red'><strong>协议栈：</strong></font>各层的所有协议被称为协议栈。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="服务和服务访问点"><a href="#服务和服务访问点" class="headerlink" title="服务和服务访问点"></a>服务和服务访问点</h4><p>服务（Service）：低层向上层实体提供它们之间的通信的能力</p>
<ul>
<li>服务用户（service user）</li>
<li>服务提供者（service provider）</li>
</ul>
<p>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务导师通过服务访问原语来进行交互 —– 形式</p>
<p>服务访问点 SAP（Services Access Point）：上层使用下层提供的服务通过层间的接口—地点；</p>
<ul>
<li>例子：邮箱</li>
<li>地址（address）：下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>例子：传输层的SAP：端口（port）</li>
</ul>
<h4 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h4><p><font color='red'><strong>面相连接的服务-方式</strong></font></p>
<ul>
<li>面向连接的服务（Connection-oriented Service）<ul>
<li>连接（Connection）：两个通信实体为进行通信建立的一种结合</li>
<li>面向连接的服务通信的过程：建立连接，通信，拆除连接</li>
<li>面相连接的服务的例子：网络层的连接被称为虚电路</li>
<li>适用范围：对于大的数据块要传输；不适合小的零星报文</li>
<li>特点：保序</li>
<li>服务类型：<ul>
<li>可靠的信息流 传送页面（可靠的获得，通过接收方的确认）</li>
<li>可靠的字节流  远程登录</li>
<li>不可靠的连接  数字化声音</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>面向无连接的服务</p>
<ul>
<li>无连接的服务（Connectionless Service）<ul>
<li>无连接服务<ul>
<li>两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃（eg: 寄信）</li>
</ul>
</li>
<li>特点<ul>
<li>不可靠</li>
<li>可能重复</li>
<li>可能失序</li>
</ul>
</li>
<li>IP 分组，数据包</li>
<li>使用范围<ul>
<li>适合 传送零星数据</li>
</ul>
</li>
<li>服务类型<ul>
<li>不可靠的数据报 电子方式的函件</li>
<li>有确认的数据报 挂号信</li>
<li>请求回答 信息查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚电路是计算机网络中的一个概念，它是一种面向连接的通信方式，与无连接通信方式相对应。虚电路在数据传输之前需要建立连接，传输完成后需要释放连接。</p>
<p>虚电路通常分为两个阶段：建立阶段和数据传输阶段。在建立阶段，通信双方需要通过一系列握手操作来建立虚电路连接，并分配一些资源，例如缓存空间、带宽等。在数据传输阶段，数据包沿着已建立的虚电路传输，数据传输完成后需要释放虚电路连接，释放之后分配的资源也会被释放。</p>
<p>虚电路有以下优点：</p>
<ol>
<li><p>提高网络传输效率：虚电路在数据传输之前需要建立连接，建立连接时可以分配资源，这样可以提高网络传输效率。</p>
</li>
<li><p>可靠性较高：虚电路在数据传输之前需要建立连接，通信双方可以进行一些检查和配置，从而提高通信的可靠性。</p>
</li>
<li><p>提供服务质量保证：虚电路可以为数据传输提供一定的服务质量保证，例如带宽保障、延迟保证等。</p>
</li>
<li><p>支持流量控制和拥塞控制：虚电路可以支持流量控制和拥塞控制，从而避免数据传输过程中出现拥塞和数据丢失等问题。</p>
</li>
</ol>
<p>虚电路也有一些缺点。例如，建立虚电路需要一定的开销，会增加网络传输的延迟。同时，虚电路的资源分配也会对网络的利用率产生一定的影响。</p>
<p>总之，虚电路是计算机网络中的一种通信方式，它是一种面向连接的通信方式，与无连接通信方式相对应。虚电路在数据传输之前需要建立连接，传输完成后需要释放连接。</p>
</blockquote>
<h4 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h4><p>服务和协议的区别</p>
<ul>
<li>服务（Service）：低层实体向上层实体提供它们之间通信的能力，是通过原语（primitive）来操作的，垂直</li>
<li>协议（protocol）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平</li>
</ul>
<p>服务与协议的联系</p>
<ul>
<li>本层<font color='red'><strong>协议的实现</strong></font>要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层<font color='red'><strong>提供更高级的服务</strong></font></li>
</ul>
<h3 id="数据单元（DU）"><a href="#数据单元（DU）" class="headerlink" title="数据单元（DU）"></a>数据单元（DU）</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531122235050.png" alt="image-20230531122235050" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531122248193.png" alt="image-20230531122248193" style="zoom:67%;" />

<h3 id="分层处理和实现复杂系统的好处"><a href="#分层处理和实现复杂系统的好处" class="headerlink" title="分层处理和实现复杂系统的好处"></a>分层处理和实现复杂系统的好处</h3><p><font color='red'><strong>对于复杂的系统</strong></font></p>
<p><strong>概念化</strong>：结构清晰，便于表示网络组件，以及描述其相互关系</p>
<p><strong>结构化</strong>：模块化更易于维护和系统升级</p>
<ul>
<li>改变某一层服务的实现不影响系统中的其他层次<ul>
<li>对于其他层次而言是透明的</li>
</ul>
</li>
<li>如改变登机程序并不影响系统的其他部分<ul>
<li>改变2个秘书使用的通信方式不影响2个翻译的工作</li>
<li>改变2个翻译使用的语言也不影响上下2个层次的工作</li>
</ul>
</li>
</ul>
<h3 id="Internet-协议栈"><a href="#Internet-协议栈" class="headerlink" title="Internet 协议栈"></a>Internet 协议栈</h3><p><font color='red'><strong>应用层：</strong></font>网络应用</p>
<p>应用层是网络应用程序及它们的应用层协议存留的地方。</p>
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务</li>
<li>FTP（文件传输协议，端到端）、SMTP（简单邮件传输协议）、HTTP（超文本传输协议）、DNS（域名系统）</li>
</ul>
<p><font color='red'><strong>传输层：</strong></font>主机之间的数据传输</p>
<p>因特网的运输层在应用程序端点之间传送应用层报文</p>
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信</li>
<li>TCP、UDP</li>
</ul>
<p><font color='red'><strong>网络层：</strong></font>为数据报从源目的选择路由</p>
<p>因特网的网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机</p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP，路由协议<ul>
<li>该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。</li>
<li>IP只有一个，所有具有网络层的因特网组件必须运行IP。</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>链路层：</strong></font>相邻网络节点间的数据传输</p>
<p>因特网的网络层通过和源和目的地之间的一系列路由器路由数据报，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据报上传给网络层。</p>
<ul>
<li>2个相邻2点的通信，点到点通信，可靠或不可靠</li>
<li>点对点协议（PPP：用于在两个点之间建立可靠的数据传输连接），802.11（WiFi），Ethernet</li>
</ul>
<p><font color='red'><strong>物理层：</strong></font>在线路上传送bit</p>
<p>链路层的任务是将整个帧从一个网络元素一到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点</p>
<h3 id="ISO-x2F-OSI-参考模型"><a href="#ISO-x2F-OSI-参考模型" class="headerlink" title="ISO&#x2F;OSI 参考模型"></a>ISO&#x2F;OSI 参考模型</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531124559929.png" alt="image-20230531124559929" style="zoom:50%;" />

<p><font color='red'><strong>表示层：</strong></font>允许应用解释传输的数据，e.g. ，加密，压缩，机器相关的表示转换</p>
<p><font color='red'><strong>会话层：</strong></font>数据交换的同步，检查点，恢复</p>
<p>互联网协议栈没有这两层！</p>
<ul>
<li>这些服务，如果需要的话，必须被应用实现</li>
</ul>
<h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531124633968.png" alt="image-20230531124633968" style="zoom:67%;" />

<blockquote>
<p>计算机网络协议层次的封装是指在数据传输过程中，将数据按照协议层次进行封装和解封装的过程。计算机网络通常按照OSI参考模型或TCP&#x2F;IP协议族进行分层，每个层次都有自己的协议和功能。</p>
<p>在数据传输过程中，每个层次都会添加自己的协议头和协议尾，从而形成一个完整的数据包。发送方在发送数据时，会按照协议层次将数据进行封装，将上层数据添加到下层协议头之后，形成一个完整的数据包。接收方在接收数据时，会按照协议层次将数据进行解封装，将下层协议头和尾去掉，提取出上层数据。</p>
<p>计算机网络协议层次的封装具有以下优点：</p>
<ol>
<li><p>提高数据传输的可靠性：通过分层的方式，每个层次都只负责自己的功能，从而减少了不必要的冗余信息，提高了数据传输的可靠性。</p>
</li>
<li><p>提高网络的灵活性和可扩展性：通过分层的方式，网络可以根据不同的需求和应用场景进行定制，提高了网络的灵活性和可扩展性。</p>
</li>
<li><p>便于实现和维护：通过分层的方式，每个层次都有自己的协议和功能，便于实现和维护。</p>
</li>
</ol>
<p>在实际应用中，计算机网络协议层次的封装通常用于数据传输和通信等方面。例如，在TCP&#x2F;IP协议族中，每个层次都有自己的协议和功能，例如HTTP、FTP、SMTP等应用层协议，TCP和UDP传输层协议，IP网络层协议和以太网物理层协议等。</p>
<p>需要注意的是，计算机网络协议层次的封装也存在一些问题，例如在分层的过程中可能会增加延迟和开销，网络安全性和隐私性也需要得到保护。为了解决这些问题，用户可以使用一些安全机制，例如加密、数字签名等，来保护数据的安全性和隐私性。</p>
<p>总之，计算机网络协议层次的封装是指将数据按照协议层次进行封装和解封装的过程。这种封装方式具有提高数据传输可靠性、提高网络的灵活性和可扩展性、便于实现和维护等优点。</p>
</blockquote>
<h3 id="各层次的协议数据单元"><a href="#各层次的协议数据单元" class="headerlink" title="各层次的协议数据单元"></a>各层次的协议数据单元</h3><p>应用层：报文（message）</p>
<ul>
<li>报文：应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议域另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为<strong>报文</strong>。</li>
</ul>
<p>传输层：报文段（segment）：TCP段，UDP数据报</p>
<p>网络层：分组（packet）（如果无连接方式：数据报 datagram）</p>
<p>数据链路层：帧（frame）</p>
<p>物理层：位（bit）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>组成角度看 什么是互联网<ul>
<li>边缘 ： 端系统（包括应用） + 接入网</li>
<li>核心 ： 网络交换设备 + 通信链路</li>
<li>协议 ： 对等层实体通信过程中遵守的规则的集合<ul>
<li>语法，语义，时序</li>
</ul>
</li>
</ul>
</li>
<li>为了实现复杂的网络功能，采用分层方式设计、实现和调试<ul>
<li>应用层、传输层、网络层、数据链路层、物理层</li>
<li>协议数据单位<ul>
<li>报文、报文段、分组、帧、位</li>
</ul>
</li>
</ul>
</li>
<li>从 服务角度 看互联网<ul>
<li>通信服务基础设施<ul>
<li>提供的通信服务： 面向连接 无连接</li>
</ul>
</li>
<li>应用</li>
</ul>
</li>
<li>应用之间的交互<ul>
<li>C&#x2F;S 模式</li>
<li>P2P 模式</li>
</ul>
</li>
<li>数据交换<ul>
<li>分组数据交换</li>
<li>线路交换</li>
</ul>
</li>
<li>比较 线路交换和 分组交换</li>
<li>分组交换的 2 中方式<ul>
<li>虚电路</li>
<li>数据报</li>
</ul>
</li>
<li>接入网和物理媒介<ul>
<li>接入网技术<ul>
<li>住宅：ADSL，拨号，cable modem</li>
<li>单位：以太网</li>
<li>无线接入方式</li>
</ul>
</li>
<li>物理媒介<ul>
<li>光纤，同轴电缆，以太网，双绞线</li>
</ul>
</li>
</ul>
</li>
<li>ISP 层次结构</li>
<li>分组交换网络中 延迟和丢失是如何发生的<ul>
<li>延迟的组成：<ul>
<li>处理</li>
<li>传输</li>
<li>传播</li>
<li>排队</li>
</ul>
</li>
</ul>
</li>
<li>网络的分层体系结构<ul>
<li>分层体系结构</li>
<li>服务</li>
<li>协议数据单元</li>
<li>封装与解封装</li>
</ul>
</li>
<li>历史</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>在本章中，我们学习有关网络应用的原理和实现方面的知识。我们从定义关键的应用层概念开始，其中包括应用程序所需要的网络服务、客户和服务器、进程、运输层接口。</p>
<p>应用层是我们学习协议非常好的起点，它最为我们熟悉。</p>
<p><strong>目标</strong></p>
<ul>
<li>网络应用的原理：网络应用协议的概念和实现方面<ul>
<li>传输层的服务模型</li>
<li>客户-服务器模式</li>
<li>对等模式（peer-to-peer)</li>
<li>内容分发网络</li>
</ul>
</li>
<li>网络应用的实例：互联网流行的应用层协议<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP&#x2F;POP3&#x2F;IMAP</li>
<li>DNS</li>
</ul>
</li>
<li>编程：网络应用程序<ul>
<li><strong>Socket API</strong></li>
</ul>
</li>
</ul>
<p><strong>创建一个新的网络应用</strong></p>
<p><font color='red'><strong>编程</strong></font></p>
<ul>
<li>在不同的端系统上运行</li>
<li>通过网络基础设施提供的服务，应用进程彼此通信</li>
<li>如 WEB<ul>
<li>web 服务器软件与浏览器软件通信</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>网络核心中没有应用层软件</strong></font></p>
<ul>
<li>网络核心没有应用层功能</li>
<li>网络应用只在端系统上存在，快速网络应用开发和部署</li>
</ul>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h3><p>可能的应用架构：</p>
<ul>
<li>客户-服务器模式（C&#x2F;S：client&#x2F;server）</li>
<li>对等模式（P2P：Peer To Peer）</li>
<li>混合体：客户-服务器和对等体系结构</li>
</ul>
<h4 id="客户-服务器（C-x2F-S）体系结构"><a href="#客户-服务器（C-x2F-S）体系结构" class="headerlink" title="客户-服务器（C&#x2F;S）体系结构"></a>客户-服务器（C&#x2F;S）体系结构</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531171024810.png" alt="image-20230531171024810" style="zoom:50%;" />

<p>在 客户-服务器体系结构 中，有一个总是打开的主机，称为服务器，它服务于来自许多其他称为客户的主机请求。</p>
<p><font color='red'><strong>服务器：</strong></font></p>
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知的端口号（约定）</li>
<li>扩展性：服务器场<ul>
<li>数据中心进行扩展</li>
<li>扩展性差</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>客户端：</strong></font></p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态IP地址</li>
<li>不直接与其它客户端通信</li>
</ul>
<h4 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a>对等体（P2P）体系结构</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531171454872.png" alt="image-20230531171454872" style="zoom:50%;" />

<ul>
<li>几乎没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器<ul>
<li>自扩展性：新peer节点带来新的服务能力，当然也带来新的服务请求</li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变IP地址<ul>
<li>难以管理</li>
</ul>
</li>
<li>例子：Gnutella，迅雷</li>
</ul>
<blockquote>
<p>P2P体系结构是指一种点对点的计算机网络架构，它将节点连接在一起，形成一个自组织的网络。P2P网络中的每个节点都可以充当客户端和服务器，节点之间可以直接交换信息和资源，而不需要通过中心化的服务器进行交互。</p>
<p>P2P体系结构通常分为两种类型：纯P2P和混合P2P。纯P2P体系结构中，每个节点都具有相同的功能和贡献，每个节点都可以直接与其他节点进行通信和交换资源。混合P2P体系结构中，除了节点之间的直接交互外，还包括一些中心化的服务器，用于提供一些服务，例如索引、查找等。</p>
<p>P2P体系结构具有以下优点：</p>
<ol>
<li><p>分布式：P2P体系结构不需要中心化的服务器，节点之间可以直接交互和通信，从而提高了网络的灵活性和可扩展性。</p>
</li>
<li><p>自组织：P2P体系结构可以根据节点的加入和退出，自动组织和调整网络拓扑结构。</p>
</li>
<li><p>可靠性：P2P体系结构具有较高的容错性和可靠性，节点之间可以互相备份和恢复数据，从而减少了数据丢失的风险。</p>
</li>
</ol>
<p>需要注意的是，P2P体系结构也存在一些问题，例如版权侵权、恶意软件等。为了保护P2P网络的安全性，用户需要注意资源的合法性和安全性，不要下载和分享非法或者有害的资源。</p>
<p>在实际应用中，P2P体系结构通常用于文件共享、流媒体传输和在线游戏等方面。例如，用户可以使用P2P网络共享文件和音乐，从而实现快速的文件传输和资源共享。另外，一些流媒体服务也使用P2P网络来传输视频和音频流，以提高传输效率和减轻服务器负载。此外，P2P网络还可以用于在线游戏中，实现多人游戏的联机功能，从而提高游戏的互动性和趣味性。</p>
<p>总之，P2P体系结构是一种点对点的计算机网络架构，它将节点连接在一起，形成一个自组织的网络。P2P体系结构具有分布式、自组织、可靠性等优点，在文件共享、流媒体传输和在线游戏等方面有着广泛的应用。</p>
</blockquote>
<h4 id="C-x2F-S和P2P体系结构的混合体"><a href="#C-x2F-S和P2P体系结构的混合体" class="headerlink" title="C&#x2F;S和P2P体系结构的混合体"></a>C&#x2F;S和P2P体系结构的混合体</h4><p><font color='red'><strong>Napster</strong></font></p>
<ul>
<li>文件搜索：集中<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul>
</li>
<li>文件传输：P2P<ul>
<li>任意peer节点之间</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>即时通信</strong></font></p>
<ul>
<li>在线检测：集中<ul>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li>两个用户之间聊天：P2P</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><font color='red'><strong>进程：</strong></font>在主机上运行的应用程序</p>
<ul>
<li><font color='red'><strong>客户端进程：</strong></font>发起通信的进程</li>
<li><font color='red'><strong>服务器进程：</strong></font>等待连接的进程</li>
</ul>
<p>在同一个主机内，使用<font color='red'>进程间通信机制</font>通信（操作系统定义）</p>
<p>不同主机，通过交换<font color='red'><strong>报文（Message）</strong></font>来通信</p>
<ul>
<li>使用OS提供的通信服务</li>
<li>按照应用协议交换报文<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：P2P架构的应用也有客户端进程和服务器进程之分</p>
</blockquote>
<p>多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<font color='red'><strong>套接字</strong></font>（socket）的软件接口向网络发送报文和从网络接收报文。</p>
<blockquote>
<p>套接字是同一台主机内应用层与运输层之间的接口。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。</p>
<p>应用程序开发者对于运输层的控制仅限于：</p>
<ul>
<li>选择运输层协议</li>
<li>也许能设定几个运输层参数，如最大缓存和最大报文段长度等</li>
</ul>
</blockquote>
<h3 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a>分布式进程通信需要解决的问题</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531173846195.png" alt="image-20230531173846195" style="zoom:67%;" />

<ul>
<li>问题1 ： 进程标示和寻址问题（服务用户）</li>
<li>问题2 ： 传输层 - 应用层提供服务是如何（服务）<ul>
<li>位置： 层间页面 的 SAP（TCP&#x2F;IP ：Socket）</li>
<li>形式：应用程序接口 API （TCP&#x2F;IP：socket API）</li>
</ul>
</li>
<li>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，使用 OS 提供的 API，调用网络基础设施提供通信服务传报文，实现应用时序等</li>
</ul>
</li>
</ul>
<h4 id="问题1：对进程进行编址（addressing）"><a href="#问题1：对进程进行编址（addressing）" class="headerlink" title="问题1：对进程进行编址（addressing）"></a>问题1：对进程进行编址（addressing）</h4><p>进程为了接收报文，必须有一个<strong>标识</strong>，即：SAP（发送也需要标识）</p>
<ul>
<li>主机：唯一的 32位 <font color='red'><strong>IP地址</strong></font><ul>
<li>仅仅有IP地址不能够唯一标识一个进程：在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li><font color='red'><strong>端口号</strong></font>（Port Numbers）</li>
</ul>
<p>一些知名端口号的例子：</p>
<ul>
<li>HTTP： TCP  80  Mail：  TCP25  ftp:   TCP 2</li>
</ul>
<p>一个进程：用IP + port标示 端节点</p>
<p>本质上，一对主机进程之间的通信由2个端节点构成</p>
<h4 id="问题2：传输层提供的服务-需要穿过层间的信息"><a href="#问题2：传输层提供的服务-需要穿过层间的信息" class="headerlink" title="问题2：传输层提供的服务-需要穿过层间的信息"></a>问题2：传输层提供的服务-需要穿过层间的信息</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531174827154.png" alt="image-20230531174827154" style="zoom: 67%;" />

<ul>
<li>层间接口必须要携带的信息<ul>
<li>要传输的报文（对于本层来说：SDU）</li>
<li>谁传的：对方的应用进程的标示：IP + TCP（UDP）端口</li>
<li>传给谁：对方的应用进程的标示：对方的 IP+TCP（UDP）端口号</li>
</ul>
</li>
<li>传输层实体（tcp或者udp实体），根据这些信息进行TCP报文段（UDP数据报）的封装<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP，目标IP</li>
</ul>
</li>
</ul>
<blockquote>
<p>传输层实体是指计算机网络中传输层的数据传输实体，通常包括TCP（Transmission Control Protocol）实体和UDP（User Datagram Protocol）实体。</p>
<p>TCP是一种面向连接的协议，它提供可靠的数据传输和流量控制，保证了数据的可靠性和完整性。TCP实体在数据传输之前需要建立连接，通过三次握手协议来确保连接的可靠性。在数据传输过程中，TCP实体还可以进行数据分段和重传，从而保证数据的可靠性和流量控制。</p>
<p>UDP是一种无连接的协议，它提供了快速的数据传输和简单的错误检测，但不保证数据的可靠性和完整性。UDP实体在数据传输之前不需要建立连接，数据也不需要进行分段和重传。UDP实体通常用于实时性要求比较高的应用，例如网络游戏、语音通信等。</p>
<p>需要注意的是，TCP实体和UDP实体的选择取决于不同的应用场景和需求。如果数据传输的可靠性和完整性比较重要，通常选择TCP实体；如果数据传输的实时性比较重要，通常选择UDP实体。</p>
<p>总之，传输层实体是指计算机网络中传输层的数据传输实体，通常包括TCP实体和UDP实体。TCP实体提供可靠的数据传输和流量控制，而UDP实体提供快速的数据传输和简单的错误检测。实际使用时需要根据不同的应用场景和需求来选择合适的传输层实体。</p>
</blockquote>
<h4 id="问题2：传输层提供的服务-层间信息的代表"><a href="#问题2：传输层提供的服务-层间信息的代表" class="headerlink" title="问题2：传输层提供的服务-层间信息的代表"></a>问题2：传输层提供的服务-层间信息的代表</h4><ul>
<li><p>如果<strong>Socket API</strong>每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p>
</li>
<li><p>用个代号标示通信的双方或者单方：socket</p>
</li>
<li><p>就像OS打开文件返回的句柄一样</p>
<ul>
<li>对句柄的操作，就是对文件的操作</li>
</ul>
</li>
<li><p>TCP socket：</p>
<ul>
<li>TCP服务，两个进程之间的通信需要之前要建立连接<ul>
<li>两个进程通信会<font color='red'>持续</font>一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的通信关系，<font color='red'>本地标示</font></li>
<li>穿过层间接口的信息量<font color='red'>最小</font></li>
<li>TCP  socket：源IP，源端口，目标IP，目标IP，目标端口</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230422143017472.png" alt="image-20230422143017472" style="zoom:67%;" /></li>
</ul>
<p><strong>TCP之上的套接字（socket）</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531181736523.png" alt="image-20230531181736523" style="zoom:67%;" />

<p>对于使用面向连接服务（TCP）的应用而言，套接字是<strong>4元组</strong>的一个具有<font color='red'>本地意义的标示</font></p>
<ul>
<li>4元组：<font color='red'><strong>源IP，源port，目标IP，目标port</strong></font></li>
<li>唯一的指定一个会话（2个进程之间的会话关系）</li>
<li>应用使用这个<strong>标示</strong>，与远程的应用进程通信</li>
<li>不必再每一个报文的发送都要指定这 4元组</li>
<li>就像使用操作系统打开一个文件，OS返回一个文件句柄医用，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li>
<li>简单，便于管理</li>
</ul>
<h4 id="问题2：传输层提供的服务-层间信息代码"><a href="#问题2：传输层提供的服务-层间信息代码" class="headerlink" title="问题2：传输层提供的服务-层间信息代码"></a>问题2：传输层提供的服务-层间信息代码</h4><ul>
<li><p>UDP socket：</p>
<ul>
<li><p>UDP服务，两个进程之间的通信需要之前无需建立连接</p>
<ul>
<li><p>每个报文都是独立传输的</p>
</li>
<li><p>前后报文可能给不同的分布式进程</p>
</li>
</ul>
</li>
<li><p>因此，只能用一个整数表示本应用的实体的标示</p>
<ul>
<li>因为这个报文可能传给另外一个分布式进程</li>
</ul>
</li>
<li><p>穿过层间接口的信息大小最小</p>
</li>
<li><p>UDP socket：本IP，本端口</p>
</li>
<li><p>但是传输 报文 时：必须要提供对方IP，port</p>
<ul>
<li>接收报文时：传输层需要上传对方的IP，port</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>UDP之上的套接字（socket）</strong></p>
<ul>
<li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有<font color='red'><strong>本地意义的标示</strong></font><ul>
<li>二元组：IP，port（源端指定）</li>
<li>UDP套接字指定了应用所在的一个<font color='red'><strong>端节点（end point）</strong></font></li>
<li>在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的 ip 和 port</li>
<li>但是在发送报文时，必须要指定对方的 IP 和 UDP port（另外一个 端节点）</li>
</ul>
</li>
</ul>
<p><strong>套接字（socket）</strong></p>
<ul>
<li>进程向 <strong>套接字</strong> 发送报文 或从 套接字接收报文</li>
<li>套接字 &lt; - &gt; 门户<ul>
<li>发送 进程将报文推出门户，发送进程依赖于传输层设施在 另外一侧的门将报文交付给接受进程</li>
<li>接受进程从门的另外一侧的门户 收到 报文（依赖于传输层设施）</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230422144843994.png" alt="image-20230422144843994" style="zoom:67%;" />

<h4 id="问题3：如何使用-传输层提供的服务实现应用"><a href="#问题3：如何使用-传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用 传输层提供的服务实现应用"></a>问题3：如何使用 传输层提供的服务实现应用</h4><ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，通过API 调用 网络基础设施提供的通信服务传报文，解析报文，实现应用时序等</li>
</ul>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>定义了：运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的<font color='red'>报文类型</font>：请求和应答报文</li>
<li>各种报文类型的<font color='red'>语法</font>：报文中的各个字段及其描述</li>
<li>字段的<font color='red'>语义</font>：即字段取值的含义</li>
<li>进程何时、如何发送报文即对报文进行响应的<font color='red'>规则</font></li>
</ul>
<p>应用协议仅仅是应用的一个组成部分</p>
<ul>
<li>Web应用：HTTP协议，web客户端，web服务器，HTML</li>
</ul>
<p><font color='red'><strong>公开协议：</strong></font></p>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>如HTTP、SMTP</li>
</ul>
<p><font color='red'><strong>专用（私有）协议：</strong></font></p>
<ul>
<li>协议不公开</li>
<li>如：Skype</li>
</ul>
<h3 id="运输服务"><a href="#运输服务" class="headerlink" title="运输服务"></a>运输服务</h3><h4 id="如何描述传输层的服务"><a href="#如何描述传输层的服务" class="headerlink" title="如何描述传输层的服务"></a>如何描述传输层的服务</h4><ul>
<li><p><font color='red'><strong>数据丢失率</strong></font></p>
<ul>
<li>有些应用在要求 100% 的可靠数据传输（如 文件）</li>
<li>有些应用（如 音频）能容忍一定比例下的数据丢失</li>
</ul>
<blockquote>
<p>运输层协议能够潜在地向应用程序提供的一个重要服务是进程到进程的可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程。</p>
</blockquote>
</li>
<li><p><font color='red'><strong>吞吐</strong></font></p>
<ul>
<li>一些应用（如多媒体）必须需要最小限度的 吞吐，从而使得应用能够有效运转</li>
<li>一些应用能够充分理由可供使用的吞吐（弹性应用）</li>
</ul>
<blockquote>
<p>运输层协议能够以某种特定的速率提供确保的可用吞吐量，具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>。</p>
<p>带宽敏感的应用具有特定的吞吐量要求，而<strong>弹性应用</strong>能够根据当时可用的带宽或多或少地利用可供使用的吞吐量。（像：电子邮件、文件传输以及Web传送都属于弹性应用。）</p>
</blockquote>
</li>
<li><p><font color='red'><strong>延迟</strong></font></p>
<ul>
<li>一些应用出于 有效性 考虑，对数据传输有严格时间限制<ul>
<li>Internet电话、交互式游戏</li>
<li>延迟、延迟差</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='red'><strong>安全性</strong></font></p>
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
</li>
</ul>
<h4 id="常见应用对传输服务的要求"><a href="#常见应用对传输服务的要求" class="headerlink" title="常见应用对传输服务的要求"></a>常见应用对传输服务的要求</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230422150547670.png" alt="image-20230422150547670" style="zoom:67%;" />

<h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><h4 id="TCP和UDP服务"><a href="#TCP和UDP服务" class="headerlink" title="TCP和UDP服务"></a>TCP和UDP服务</h4><p><font color='red'><strong>TCP服务</strong></font></p>
<ul>
<li><p>可靠的传输服务</p>
<ul>
<li>通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。</li>
<li>当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
</ul>
</li>
<li><p>流量控制：发送方不会淹没接收方</p>
</li>
<li><p>拥塞控制：当网络出现拥堵时，能抑制发送方</p>
</li>
<li><p>不能提供的服务：时间保证、最小吞吐量保证和安全</p>
</li>
<li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p>
</li>
</ul>
<p>在应用层数据报文开始流动之前，TCP让客户和服务器相互交换运输层信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。当应用程序结束报文发送时，必须拆除该连接。</p>
<p>TCP还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程（客户或服务器）。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p>
<p><font color='red'><strong>UDP服务</strong></font></p>
<ul>
<li>不可靠的数据传输</li>
<li><strong>不提供</strong>的服务：可靠，流量控制，拥塞控制，带宽保证，建立连接</li>
</ul>
<p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最低限度的服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP提供一种不可靠的数据传输服务，不仅如此，到达接收进程的报文也可能是乱序到达的。</p>
<p>UDP不包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据，（然而，值得注意的是：实际端到端吞吐量可能小于该速率，这可能是由中间链路的带宽受限或拥塞而造成的。）</p>
<h4 id="UDP存在的必要性"><a href="#UDP存在的必要性" class="headerlink" title="UDP存在的必要性"></a><strong>UDP存在的必要性</strong></h4><ul>
<li><p>能够区分不同的进程，而 IP 服务不能</p>
<ul>
<li>在 IP 提供的主机到主机 端到端功能的基础上，区分了 主机的应用进程</li>
</ul>
</li>
<li><p><font color='red'><strong>无需建立连接：</strong></font>省去了建立连接的时间，适合事务性的应用</p>
</li>
<li><p><font color='red'><strong>不做可靠性的工作</strong></font>。例如 检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用</p>
<ul>
<li>因为为了实现可靠性（正确性、保序等），必须付出时间代价（检错重发）</li>
</ul>
</li>
<li><p>没有了 拥塞控制和流量控制，</p>
<p>应用能够按照设定的速度发送数据</p>
<ul>
<li>而在 tcp 上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量限制和拥塞限制</li>
</ul>
</li>
</ul>
<h4 id="Internet-应用及其应用层协议和传输协议"><a href="#Internet-应用及其应用层协议和传输协议" class="headerlink" title="Internet 应用及其应用层协议和传输协议"></a>Internet 应用及其应用层协议和传输协议</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230422152425471.png" alt="image-20230422152425471" style="zoom:67%;" />

<h4 id="安全TCP（SSL）"><a href="#安全TCP（SSL）" class="headerlink" title="安全TCP（SSL）"></a>安全TCP（SSL）</h4><p><font color='red'><strong>TCP&amp;UDP</strong></font></p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码</li>
</ul>
<p><font color='red'><strong>SSL（安全套接字协议）</strong></font></p>
<ul>
<li>在TCP上实现，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<p><font color='red'><strong>SSL在应用层</strong></font></p>
<ul>
<li>应采用SSL库，SSL库采用TCP通信</li>
</ul>
<p><font color='red'><strong>SSL socket api</strong></font></p>
<ul>
<li>应用通过 API 将明文交给socket，SSL将其加密在互联网上传输</li>
</ul>
<blockquote>
<p>SSL协议（安全套接字协议）在保证网络通信安全方面有以下优点：</p>
<p>机密性：SSL协议可以使用公钥加密和对称加密相结合的方式来保证数据的机密性，防止数据被窃听和窃取。</p>
<p>完整性：SSL协议可以使用数字签名和消息认证码来保证数据的完整性，防止数据被篡改和伪造。</p>
<p>可靠性：SSL协议可以使用证书认证和安全通道来保证数据传输的可靠性，防止数据丢失和损坏。</p>
<p>需要注意的是，SSL协议也存在一些缺点，例如握手过程的延迟、证书认证的复杂性、加密算法的漏洞等。为了提高SSL协议的安全性和可靠性，需要不断更新和升级SSL协议，使用更加安全的加密算法和认证方式。</p>
<p>在实际应用中，SSL协议通常用于网站的安全认证和加密传输等方面。例如，网站可以通过SSL协议来使用HTTPS（Hyper Text Transfer Protocol Secure）协议进行安全加密传输，从而保证用户的个人信息和交易数据的安全性。同时，SSL协议也可以用于电子邮件、即时通讯、远程访问等方面，保护网络通信的安全性。</p>
<p>总之，SSL协议是一种用于保护网络通信安全的加密协议，它可以保证数据的机密性、完整性和可靠性。在实际应用中，SSL协议通常用于网站的安全认证和加密传输等方面，是保护网络通信安全的重要手段。</p>
</blockquote>
<h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><h3 id="Web-与-HTTP"><a href="#Web-与-HTTP" class="headerlink" title="Web 与 HTTP"></a>Web 与 HTTP</h3><p>Web的应用层协议是HTTP，它定义了在浏览器和Web服务器之间传输的报文格式和序列。</p>
<ul>
<li><p>Web服务器实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址</p>
</li>
<li><p><font color='red'><strong>Web页：</strong></font>由一些<font color='red'>对象</font>组成</p>
</li>
<li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
</li>
<li><p>Web页含有一个<font color='red'>基本的HTML文件</font>，该基本HTML文件又包含若干对象的引用（链接）</p>
</li>
<li><p>通过<font color='red'><strong>URL</strong></font>对每个对象进行引用</p>
<ul>
<li><font color='red'>访问协议，用户名，口令字，端口等</font></li>
</ul>
</li>
<li><p>URL格式：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531225557005.png" alt="image-20230531225557005" style="zoom:67%;" /></li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><p><font color='red'><strong>HTTP：超文本传输协议</strong></font></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531222506984.png" alt="image-20230531222506984" style="zoom:67%;" /> 

<ul>
<li><p>HTTP是Web的应用层协议</p>
</li>
<li><p>客户&#x2F;服务器模式</p>
<ul>
<li>客户：请求、接收和显示Web对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的Web服务器</li>
</ul>
<p>客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。即HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。</p>
</li>
<li><p>HTTP 1.0：RFC 1945</p>
</li>
<li><p>HTTP 1.1：RFC 2068</p>
</li>
<li><p>HTTP 2：RFC 7540</p>
</li>
</ul>
<p><font color='red'><strong>使用TCP：</strong></font></p>
<ul>
<li>客户发起一个与服务器的TCP连接（建立套接字），端口号为80</li>
<li>服务器接受客户的TCP连接</li>
<li>在浏览器（HTTP客户端）与 Web服务器（HTTP服务器 server）交换HTTP报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ul>
<p><font color='red'><strong>HTTP是无状态的</strong></font></p>
<ul>
<li>服务器并不保存和维护关于客户的任何信息</li>
</ul>
<p>一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制，HTTP不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节（那是TCP以及协议栈较低层协议的工作）。</p>
<blockquote>
<p>假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会为刚刚为客户提供了该对象就不再做出反应，而是重新发送该对象。</p>
</blockquote>
<p><font color='red'>维护状态的协议很复杂！</font></p>
<ul>
<li>必须维护历史信息（状态）</li>
<li>如果服务器&#x2F;客户端四级，它们的状态信息可能不一致，二者的信息必须是一致的</li>
<li>无状态的服务器能够支持更多的客户端</li>
</ul>
<h4 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h4><p>HTTTP默认使用持续连接</p>
<p><font color='red'><strong>非持久HTTP</strong></font>（采用非持续连接的HTTP）</p>
<ul>
<li>最多只有一个对象在TCP连接上发送</li>
<li>下载多个对象需要多个TCP连接</li>
<li>HTTP&#x2F;1.0使用非持久连接</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531230335636.png" alt="image-20230531230335636"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531230438473.png" alt="image-20230531230438473"></p>
<blockquote>
<p>非持续连接的HTTP（HTTP&#x2F;1.0）是一种较早的HTTP协议版本，它采用非持续连接的方式进行通信。在非持续连接的HTTP中，每个请求和响应都需要建立一个新的TCP连接，完成后立即关闭连接，不保留任何状态信息。因此，每个请求和响应都需要消耗额外的时间和资源，影响了系统的性能和可伸缩性。</p>
<p>非持续连接的HTTP协议存在一些问题，例如：</p>
<ol>
<li>每个请求和响应都需要建立一个新的TCP连接，浪费了大量的时间和资源，降低了系统的性能和可伸缩性。</li>
<li>每个请求和响应都需要消耗额外的带宽和能源，增加了网络负担和环境成本。</li>
<li>非持续连接的HTTP协议无法处理复杂的Web应用程序，如在线交易、社交网络、流媒体等，因为它无法保持状态信息。</li>
</ol>
</blockquote>
<p><font color='red'><strong>持久HTTP</strong></font>（采用持续连接的HTTP）</p>
<ul>
<li>多个对象可以在一个（客户端和服务器之间的）TCP连接上传输</li>
<li>HTTP&#x2F;1.1默认使用持久连接</li>
</ul>
<p>在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。</p>
<p>如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。HTTP的默认模式是使用带流水线的持续连接。</p>
<blockquote>
<p>采用持续连接的HTTP（HTTP&#x2F;1.1）是一种较新的HTTP协议版本，它引入了持久连接的概念，即可以在同一个TCP连接上发送多个请求和响应，避免了重复建立和关闭TCP连接的开销。在持续连接的HTTP中，客户端和服务器之间的TCP连接不会在每个请求和响应之后立即关闭，而是保持连接状态，直到客户端或服务器明确要求关闭连接。</p>
<p>持续连接的HTTP协议解决了非持续连接的HTTP协议存在的一些问题，例如：</p>
<ol>
<li><p>减少了每个请求和响应之间建立和关闭TCP连接的开销，提高了系统的性能和可伸缩性。</p>
</li>
<li><p>减少了每个请求和响应消耗的带宽和能源，减轻了网络负担和环境成本。</p>
</li>
<li><p>可以处理复杂的Web应用程序，如在线交易、社交网络、流媒体等，因为它可以保持状态信息，并且可以在同一个TCP连接上发送多个请求和响应。</p>
</li>
</ol>
<p>此外，持续连接的HTTP协议还引入了HTTP管线化的概念，即可以在同一个TCP连接上同时发送多个请求，避免了请求之间的等待时间和网络拥塞。但是，HTTP管线化存在一些问题，例如请求之间的依赖关系和服务器的响应顺序等问题，因此在实际应用中需要谨慎使用。</p>
<p>总之，采用持续连接的HTTP（HTTP&#x2F;1.1）是一种较新的HTTP协议版本，引入了持久连接的概念，可以在同一个TCP连接上发送多个请求和响应，避免了重复建立和关闭TCP连接的开销，提高了系统的性能和可伸缩性。</p>
</blockquote>
<p><font color='red'><strong>HTTP&#x2F;2：</strong></font></p>
<p> HTTP&#x2F;2的主要目标是减小感知时延，其手段是经单一 TCP 连接使请求与响应多路复用，提供请求优先次序和服务器推，并提供HTTP首部字段的有效压缩。HTTP&#x2F;2不改变HTTP方法、状态码、URL或首部字段，而是改变数据格式化方法以及客户和服务器之间的传输方式。</p>
<blockquote>
<p>HTTP&#x2F;2是一种新的HTTP协议版本，它采用了一些新的技术和机制，以提高Web应用程序的性能和可伸缩性。HTTP&#x2F;2的主要特点包括：</p>
<ol>
<li><p>多路复用：HTTP&#x2F;2可以在同一个TCP连接上同时发送多个请求和响应，避免了请求之间的等待时间和网络拥塞，提高了系统的性能和可伸缩性。</p>
</li>
<li><p>二进制分帧：HTTP&#x2F;2将HTTP报文分成二进制格式的帧，可以更快地传输和解析，减少了网络负载和延迟。</p>
</li>
<li><p>头部压缩：HTTP&#x2F;2使用HPACK算法对HTTP头部进行压缩，可以减少网络负载和延迟，提高了系统的性能和可伸缩性。</p>
</li>
<li><p>服务器推送：HTTP&#x2F;2支持服务器主动推送资源到客户端缓存，可以提高页面加载速度和用户的体验。</p>
</li>
<li><p>安全性：HTTP&#x2F;2要求使用TLS加密通信，可以提高通信的安全性和隐私性。</p>
</li>
</ol>
<p>需要注意的是，HTTP&#x2F;2的实现存在一些问题和挑战，例如对老版本HTTP协议的兼容性、头部压缩算法的安全性、服务器推送的优化等，需要采取一些策略和技术来解决。此外，HTTP&#x2F;2的性能和效果也与应用程序和网络环境有关，需要对具体情况进行评估和优化。</p>
<p>总之，HTTP&#x2F;2是一种新的HTTP协议版本，采用了多路复用、二进制分帧、头部压缩、服务器推送等新技术和机制，以提高Web应用程序的性能和可伸缩性。</p>
</blockquote>
<p><strong>响应时间模型</strong></p>
<p><font color='red'><strong>往返时间RTT</strong>（round-trip time）：</font></p>
<p>一个小的分组从客户端到服务器，在返回到客户端的时间（传输时间忽略）</p>
<p>RTT包括：分组传播时延、分组在中间路由器和交换机上的排队时延、分组处理时延。</p>
<p><font color='red'>响应时间：</font></p>
<ul>
<li>一个RTT用来发起TCP连接</li>
<li>一个RTT用来HTTP请求并等待HTTP响应</li>
</ul>
<p>共：2RTT + 传输时间</p>
<blockquote>
<p>RTT是“往返时延”（Round-Trip Time）的缩写，是网络中的一个重要指标。RTT指的是从发送方发送数据开始，到接收方接收到确认消息的时间差。</p>
<p>RTT的作用是评估网络的性能和可靠性。通过测量RTT可以确定网络的延迟和带宽，从而评估网络的性能和可靠性。在网络通信中，RTT也常用于控制数据传输的速率和流量控制，以及进行拥塞控制和丢包恢复等。</p>
<p>RTT的值取决于多个因素，包括网络拓扑结构、网络负载、传输距离、网络设备等。因此，对于不同的网络应用和场景，需要根据实际情况选择合适的RTT阈值和控制策略，以达到最佳的网络性能和可靠性。</p>
<p>总之，RTT是网络中的一个重要指标，用于评估网络的性能和可靠性。它可以用于控制数据传输的速率和流量控制，以及进行拥塞控制和丢包恢复等。</p>
</blockquote>
<h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><p><font color='red'><strong>非持久HTTP的缺点：</strong></font></p>
<ul>
<li>每个对象要2个RTT（往返时延）</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>但浏览器通常打开并行TCP连接，以获取引用对象</li>
</ul>
<p><font color='red'><strong>持久HTTP</strong></font></p>
<ul>
<li>服务器在发送响应后，仍保持TCP连接</li>
<li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li>
<li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li>
</ul>
<p><font color='red'><strong>非流水方式的持久HTTP：</strong></font></p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
<p><font color='red'><strong>流水方式的持久HTTP：</strong></font></p>
<ul>
<li>HTTP&#x2F;1.1的默认模式</li>
<li>客户端遇到一个引用对象就立即产生一个请求</li>
<li>所有引用（小）对象只花费一个RTT是可能的</li>
</ul>
<h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><ul>
<li><p>两种类型的HTTP报文：<font color='red'>请求、响应</font></p>
</li>
<li><p><font color='red'><strong>HTTP请求报文：</strong></font></p>
<ul>
<li><p>ASCII（人能阅读）</p>
</li>
<li><p>绝大部分的HTTP请求报文使用GET方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230505230517969.png" alt="image-20230505230517969"  /></li>
</ul>
</li>
</ul>
<p><font color='red'><strong>请求行：</strong></font></p>
<p>3个字段：</p>
<ul>
<li>方法字段<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
</ul>
</li>
<li>URL字段<ul>
<li>带有请求对象的标识，该浏览器正在请求对象 <code>/somedir/page.html</code></li>
</ul>
</li>
<li>HTTP版本字段<ul>
<li>该例子中使用的HTTP版本是1.1</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>首部行：</strong></font></p>
<ul>
<li>Host：<a target="_blank" rel="noopener" href="http://www.someschool.edu/">www.someschool.edu</a><ul>
<li>指明了对象所在的主机</li>
<li>该首部行提供的信息是Web代理高速缓存所要求的</li>
</ul>
</li>
<li>Connection：close<ul>
<li>该浏览器告诉服务器不要麻烦地使用持续链接，它要求服务器在发送完被请求的对象后就关闭这条连接</li>
</ul>
</li>
<li>User-agent：Mozilla&#x2F;5.0<ul>
<li>用来指明用户代理，即向服务器发送请求的浏览器的类型。这里浏览器类型是Mozilla&#x2F;5.0，即Fire-fox浏览器。</li>
<li>这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本。（每个版本都由相同的URL寻址。）</li>
</ul>
</li>
<li>Accept-language：fr<ul>
<li>表示用户想得到该对象的法语版本（如果服务器中有这样的对象的话），否则，服务器应当发送它的默认版本。</li>
</ul>
</li>
</ul>
<h5 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h5> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531232515994.png" alt="image-20230531232515994" style="zoom: 67%;" />

<p><font color='red'>实体体：</font></p>
<ul>
<li>使用GET方法时，实体体为空</li>
<li>使用POST方法（提交表单等）时，使用该实体体，该实体体中包含的就是用户在表单字段中的输入值。</li>
</ul>
<h5 id="提交表单输入"><a href="#提交表单输入" class="headerlink" title="提交表单输入"></a>提交表单输入</h5><p><font color='red'><strong>Post方式：</strong></font></p>
<ul>
<li>网页通常包括表单输入</li>
<li>包含在实体主体（entity body）中的输入被提交到服务器</li>
</ul>
<p><font color='red'><strong>URL方式：</strong></font></p>
<ul>
<li>方法：GET</li>
<li>输入通过请求行的URL字段上载</li>
</ul>
<h5 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h5><p><font color='red'><strong>HTTP&#x2F;1.0</strong></font></p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD<ul>
<li>要求服务器在响应报文中不包含请求对象 -&gt; 故障跟踪</li>
<li>类似于GET方法。当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>HTTP&#x2F;1.1</strong></font></p>
<ul>
<li>GET、POST、HEAD</li>
<li>PUT<ul>
<li>将实体主体中的文件上载到URL字段规定的路径</li>
</ul>
</li>
<li>DELETE<ul>
<li>删除URL字段规定的文件</li>
</ul>
</li>
</ul>
<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230531233913216.png" alt="image-20230531233913216"></p>
<p><font color='red'><strong>状态行：</strong></font></p>
<ul>
<li>协议版本字段</li>
<li>状态码</li>
<li>相应的状态信息</li>
</ul>
<p><font color='red'><strong>首部行：</strong></font></p>
<ul>
<li>Connection：close<ul>
<li>发送完成后将关闭该TCP连接</li>
</ul>
</li>
<li>Date：<ul>
<li>服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。</li>
</ul>
</li>
<li>Server：Apache&#x2F;1.3.0<ul>
<li>该报文是由一台 Apache Web服务器产生的，它类似于HTTP请求报文中的 “User-agent:” 首部行。</li>
</ul>
</li>
<li>Last-Modified：<ul>
<li>该对象创建或最后修改的时间与日期</li>
<li>Last-Modified 首部行对既可能在本地客户也可能在网络缓存服务器（代理服务器）上的对象来说分厂重要。</li>
</ul>
</li>
<li>Content-Length：6812\r\n<ul>
<li>指示了被发送对象中的字节数</li>
</ul>
</li>
<li>Content-Type：text&#x2F;html\r\n<ul>
<li>指示了实体体中的对象是HTML文本</li>
<li>该对象类型应该正式地使用 “Content-Type：” 首部行而不是文件扩展名来指示。</li>
</ul>
</li>
</ul>
<h4 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h4><p>位于服务器 -&gt; 客户端的响应报文中的首行</p>
<p>一些状态码的例子：</p>
<ul>
<li><font color='red'>200  OK</font><ul>
<li>请求成功，请求对象包含在响应报文的后续部分</li>
</ul>
</li>
<li><font color='red'>301  Moved Permanently</font><ul>
<li>请求的对象已经被永久转移了；新的URL在响应报文的Location 首部行中指定</li>
<li>客户端软件自动用新的URL去获取对象</li>
</ul>
</li>
<li><font color='red'>400  Bad Request</font><ul>
<li>一个通用的差错代码，表示该请求不能被服务器解读</li>
</ul>
</li>
<li><font color='red'>404  Not Found</font><ul>
<li>请求的文档在该服务上没有找到</li>
</ul>
</li>
<li><font color='red'>505  HTTP Version Not Supported</font><ul>
<li>服务器不支持请求报文使用的HTTP版本。</li>
</ul>
</li>
</ul>
<h3 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h3><p>大多数主要的门户网站使用 cookies</p>
<p><font color='red'><strong>四个组成部分：</strong></font></p>
<ol>
<li>在HTTP响应报文中有一个cookie的首部行</li>
<li>在HTTP请求报文含有一个cookie的首部行</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库</li>
</ol>
<h4 id="Cookies：维护状态"><a href="#Cookies：维护状态" class="headerlink" title="Cookies：维护状态"></a>Cookies：维护状态</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602090249415.png" alt="image-20230602090249415" style="zoom:67%;" />

<h4 id="Cookies能带来什么"><a href="#Cookies能带来什么" class="headerlink" title="Cookies能带来什么"></a>Cookies能带来什么</h4><ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态（Web e-mail）</li>
</ul>
<p><font color='red'><strong>如何维持状态：</strong></font></p>
<ul>
<li>协议端节点：在多个事务上，发送端和接收端维持状态</li>
<li>cookies：http报文携带状态信息</li>
</ul>
<p><font color='red'><strong>Cookies与隐私：</strong></font></p>
<ul>
<li>Cookies允许站点知道许多关于用户的信息</li>
<li>可能将它知道的东西卖给第三方</li>
<li>使用重定向和cookie的搜索引擎还能知道用户更多的信息<ul>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li>
</ul>
</li>
<li>广告公司从站点获得信息</li>
</ul>
<h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><p>Web缓存也叫代理服务器，它是能够代表初始Web服务器来满足HTTP请求的网络实体。</p>
<h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091019336.png" alt="image-20230602091019336" style="zoom:67%;" />

<p><font color='red'><strong>目标：</strong></font>不访问<strong>原始</strong>服务器，就能满足客户的请求</p>
<ul>
<li><p>用户设置浏览器：通过缓存访问Web</p>
</li>
<li><p>浏览器将所有的HTTP请求发给缓存</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存，缓存请求原始服务器，然后在将对象返回给客户端</li>
</ul>
</li>
<li><p>缓存既是客户端又是服务器</p>
</li>
<li><p>通常缓存是由ISP购买并安装（大学、公司、居民区ISP）</p>
</li>
</ul>
<p><font color='red'><strong>为什么要使用Web缓存？</strong></font></p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li>
<li>互联网大量采用了缓存，可以使较弱的ICP也能够有效提供内容</li>
</ul>
<blockquote>
<p>Web缓存器是一种可以缓存Web页面和资源的设备或软件，它可以在用户和服务器之间充当中间代理，提供快速访问和更高的性能。Web缓存器可以将常用的Web页面和资源存储在本地缓存中，当用户请求相同的页面或资源时，可以直接从缓存中获取，避免了重复的网络请求和服务器的响应，减少了网络流量和延迟，提高了用户的体验和系统的性能。</p>
<p>Web缓存器可以部署在不同的位置和层次，例如客户端缓存、代理服务器缓存、CDN缓存等，它们之间的差别主要在于缓存的位置和范围。客户端缓存通常部署在用户设备上，可以缓存一些静态资源，例如图片、样式表、脚本等，可以提高页面的加载速度和用户的体验。代理服务器缓存通常部署在本地网络或ISP上，可以缓存一些常用的Web页面和资源，可以减少网络负载和延迟，提高系统的性能和可伸缩性。CDN缓存通常部署在全球各地的服务器上，可以缓存一些大型的静态资源，例如视频、音频、图片等，可以提高全球用户的访问速度和体验。</p>
<p>需要注意的是，Web缓存器存在一些问题和挑战，例如缓存更新的问题、缓存一致性的问题、缓存污染的问题等，需要采取一些策略和技术来解决。例如，可以采用缓存过期时间、缓存验证机制、缓存命中率监控等技术来优化缓存策略和性能。此外，Web缓存器还需要考虑安全性、隐私性和合法性等方面的问题，避免出现缓存泄露、缓存污染、缓存劫持等安全问题。</p>
<p>总之，Web缓存器是一种可以缓存Web页面和资源的设备或软件，可以在用户和服务器之间充当中间代理，提供快速访问和更高的性能。Web缓存器可以部署在不同的位置和层次，例如客户端缓存、代理服务器缓存、CDN缓存等，可以采取一些策略和技术来优化缓存策略和性能。</p>
</blockquote>
<h4 id="缓存示例"><a href="#缓存示例" class="headerlink" title="缓存示例"></a>缓存示例</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091359243.png" alt="image-20230602091359243" style="zoom:67%;" /> 

<h4 id="缓存示例：更快的接入链路"><a href="#缓存示例：更快的接入链路" class="headerlink" title="缓存示例：更快的接入链路"></a>缓存示例：更快的接入链路</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091445676.png" alt="image-20230602091445676" style="zoom:67%;" /> 

<h4 id="缓存示例：安装本地缓存"><a href="#缓存示例：安装本地缓存" class="headerlink" title="缓存示例：安装本地缓存"></a>缓存示例：安装本地缓存</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091518260.png" alt="image-20230602091518260" style="zoom:67%;" />

<h4 id="缓存示例：安装本地缓存-1"><a href="#缓存示例：安装本地缓存-1" class="headerlink" title="缓存示例：安装本地缓存"></a>缓存示例：安装本地缓存</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091613391.png" alt="image-20230602091613391" style="zoom:67%;" />

<h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>HTTP有一种机制，允许缓存器证实它的对象是最新的。该缓存器通过发送一个条件GET执行最新检查。</p>
<ul>
<li><p><font color='red'><strong>目标：</strong></font>如果缓存器中的对象拷贝是最新的，就不要发送对象</p>
</li>
<li><p>缓存器：在HTTP请求中指定缓存拷贝的日期</p>
<p><code>If-modified-since:&lt;date&gt;</code></p>
</li>
<li><p>服务器：如果缓存拷贝陈旧，则响应报文没包含对象：</p>
<p><code>HTTP/1.0 304 Not Modified</code> </p>
<p>它告诉缓存器可以使用该对象，能向请求的浏览器转发它（该代理缓存器）缓存的对象副本。</p>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602091902035.png" alt="image-20230602091902035" style="zoom:50%;" />

<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="FTP：文件传输协议"><a href="#FTP：文件传输协议" class="headerlink" title="FTP：文件传输协议"></a>FTP：文件传输协议</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602204451613.png" alt="image-20230602204451613" style="zoom:67%;" />

<ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户&#x2F;服务器模式<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>FTP：RFC 959</li>
<li>FTP服务器：端口号为21</li>
</ul>
<h3 id="FTP：控制连接与数据连接分开"><a href="#FTP：控制连接与数据连接分开" class="headerlink" title="FTP：控制连接与数据连接分开"></a>FTP：控制连接与数据连接分开</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602205012639.png" alt="image-20230602205012639" style="zoom:67%;" />

<ul>
<li>FTP客户端与FTP服务器通过端口 21 联系，并使用<strong>TCP</strong>为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
<li>控制连接：<font color='red'>带外（“out of band”）</font>传送</li>
<li>FTP服务器维护用户的状态信息：当前路径、用户账户与控制连接对应</li>
</ul>
<h3 id="FTP命令、响应"><a href="#FTP命令、响应" class="headerlink" title="FTP命令、响应"></a>FTP命令、响应</h3><p><font color='red'><strong>命令样例：</strong></font></p>
<ul>
<li>在<strong>控制连接</strong>上以ASCII文本方式传送</li>
<li>USER username</li>
<li>PASS password</li>
<li>LIST：请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename：从远程主机的当前目录检索文件（gets）</li>
<li>STOR filename：向远程主机的当前目录存放文件（puts）</li>
</ul>
<p><font color='red'><strong>返回码样例：</strong></font></p>
<ul>
<li><p>状态码和状态信息（同HTTP）</p>
</li>
<li><p>331 Username OK,</p>
<p>password required</p>
</li>
<li><p>125 data connection</p>
<p>already open；</p>
<p>transfer starting</p>
</li>
<li><p>425 Can’t open data</p>
<p>connection</p>
</li>
<li><p>452 Error writing</p>
<p>file</p>
</li>
</ul>
<blockquote>
<p>FTP（File Transfer Protocol）是一种在计算机网络中用于文件传输的协议，它可以实现将文件从一个计算机传输到另一个计算机。FTP协议通常使用客户端&#x2F;服务器模型，客户端通过FTP客户端软件连接到FTP服务器，并通过FTP协议进行文件传输。</p>
<p>FTP协议的主要特点是可靠性、灵活性和安全性。FTP协议提供了多种传输模式和数据格式，可以灵活地适应不同场景下的文件传输需求。同时，FTP协议还支持多种身份验证和加密机制，可以确保文件传输的安全性。</p>
<p>在FTP协议中，文件传输通常由两个不同的端口进行控制和数据传输。FTP客户端通过控制端口与FTP服务器建立连接，并发送FTP命令进行文件传输的控制。FTP服务器通过数据端口与FTP客户端建立连接，并在数据端口上传输文件数据。</p>
<p>当进行FTP文件传输时，FTP客户端需要提供目标文件的路径和文件名，FTP服务器会检查是否有相应的权限，并返回文件数据的响应。FTP客户端会根据响应，向FTP服务器发送有关文件传输的命令，并在数据端口上传输文件数据。传输完成后，FTP客户端和FTP服务器会结束数据连接，并关闭控制连接。</p>
<p>需要注意的是，FTP协议的传输过程可能会受到网络环境、传输数据的大小和数量等因素的影响，可能会出现传输中断、传输速度慢等问题。因此，在进行FTP文件传输时，需要根据实际情况选择合适的传输模式和数据格式，并进行适当的优化和调整，以确保文件传输的成功和效率。</p>
<p>总之，FTP是一种在计算机网络中用于文件传输的协议，它具有可靠性、灵活性和安全性等特点，在文件传输中发挥着重要的作用。</p>
</blockquote>
<h2 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h2><h3 id="电子邮件（EMail）"><a href="#电子邮件（EMail）" class="headerlink" title="电子邮件（EMail）"></a>电子邮件（EMail）</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602212440024.png" alt="image-20230602212440024" style="zoom:50%;" />

<p><font color='red'><strong>3个主要组成部分：</strong></font></p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议：SMTP</li>
</ul>
<p><font color='red'><strong>用户代理：</strong></font></p>
<ul>
<li>又名 ”邮件阅读器“</li>
<li>撰写、编辑和阅读文件</li>
<li>如Outlook、Foxmail</li>
<li>输出和输入邮件保存在服务器上</li>
</ul>
<h3 id="EMail：邮件服务器"><a href="#EMail：邮件服务器" class="headerlink" title="EMail：邮件服务器"></a>EMail：邮件服务器</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602212828661.png" alt="image-20230602212828661" style="zoom:67%;" />

<p><font color='red'><strong>邮件服务器</strong></font></p>
<ul>
<li><font color='red'>邮箱</font>中管理和维护发送给用户的邮件</li>
<li>输出<font color='red'>报文队列</font>保持发送邮件报文</li>
<li>邮件服务器之间的<font color='red'><strong>SMTP协议</strong></font>：发送email报文<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
<h3 id="SMTP-RFC-2821"><a href="#SMTP-RFC-2821" class="headerlink" title="SMTP  [RFC 2821]"></a>SMTP  [RFC 2821]</h3><ul>
<li>使用TCP在客户端和服务器之间传送报文，端口号为25</li>
<li>直接传输：从发送方服务器到接收方服务器（一般不使用中间邮件服务器发送邮件）</li>
<li>传输的3个阶段<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
</li>
<li>命令&#x2F;响应交互<ul>
<li><font color='red'>命令</font>：ASCII文本</li>
<li><font color='red'>响应：</font>状态码和状态信息</li>
</ul>
</li>
<li>报文必须为7位ASCII码</li>
</ul>
<p>SMTP是因特网电子邮件的核心，SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。但它所具有的陈旧特征表明它仍然是一种继承的技术。</p>
<p>在用SMTP传送邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应的ASCII码邮件解码还原为多媒体数据。（但使用HTTP传送前不需要将多媒体数据编码为ASCII码）</p>
<h3 id="举例：Alice给Bob发送报文"><a href="#举例：Alice给Bob发送报文" class="headerlink" title="举例：Alice给Bob发送报文"></a>举例：Alice给Bob发送报文</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602213718488.png" alt="image-20230602213718488" style="zoom:67%;" />

<blockquote>
<p>SMTP是一种在计算机网络中用于电子邮件传输的协议，它可以实现将邮件从一个计算机传输到另一个计算机。SMTP协议通常使用客户端&#x2F;服务器模型，客户端通过SMTP客户端软件连接到SMTP服务器，并通过SMTP协议进行电子邮件传输。</p>
<p>SMTP协议的主要特点是可靠性、灵活性和安全性。SMTP协议提供了多种传输模式和数据格式，可以灵活地适应不同场景下的电子邮件传输需求。同时，SMTP协议还支持多种身份验证和加密机制，可以确保电子邮件传输的安全性。</p>
<p>在SMTP协议中，电子邮件传输通常由两个不同的端口进行控制和数据传输。SMTP客户端通过控制端口与SMTP服务器建立连接，并发送SMTP命令进行电子邮件传输的控制。SMTP服务器通过数据端口与SMTP客户端建立连接，并在数据端口上传输电子邮件数据。</p>
<p>当进行SMTP电子邮件传输时，SMTP客户端需要提供目标邮件地址、邮件主题、邮件正文等信息，SMTP服务器会检查是否有相应的权限，并返回邮件数据的响应。SMTP客户端会根据响应，向SMTP服务器发送有关电子邮件传输的命令，并在数据端口上传输邮件数据。传输完成后，SMTP客户端和SMTP服务器会结束数据连接，并关闭控制连接。</p>
<p>需要注意的是，SMTP协议的电子邮件传输过程可能会受到网络环境、邮件大小和数量等因素的影响，可能会出现传输中断、传输速度慢等问题。因此，在进行SMTP电子邮件传输时，需要根据实际情况选择合适的传输模式和数据格式，并进行适当的优化和调整，以确保电子邮件传输的成功和效率。</p>
<p>总之，SMTP是一种在计算机网络中用于电子邮件传输的协议，它具有可靠性、灵活性和安全性等特点，在电子邮件传输中发挥着重要的作用。</p>
</blockquote>
<h3 id="STMP：总结"><a href="#STMP：总结" class="headerlink" title="STMP：总结"></a>STMP：总结</h3><ul>
<li>SMTP是一个推协议</li>
<li>SMTP使用持久连接</li>
<li>SMTP要求报文（首部和主体）为7位ASCII编码</li>
<li>SMTP服务器使用CRLF。CRLF决定报文的尾部</li>
</ul>
<p><font color='red'><strong>HTTP比较：</strong></font></p>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令&#x2F;响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p><strong>SMTP：</strong>交换email报文的协议</p>
<p><strong>RFC 822：</strong>文本报文的标准：</p>
<ul>
<li>首部行：如 To，From，Subject。与SMTP命令<font color='red'>不同</font></li>
<li>主体<ul>
<li>报文：只能是ASCII码字符</li>
</ul>
</li>
</ul>
<h3 id="报文格式：多媒体扩展"><a href="#报文格式：多媒体扩展" class="headerlink" title="报文格式：多媒体扩展"></a>报文格式：多媒体扩展</h3><ul>
<li>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045,  2056</li>
<li>在报文首部用额外的行声明MIME内容类型</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602214354761.png" alt="image-20230602214354761" style="zoom:67%;" />

<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602214417955.png" alt="image-20230602214417955" style="zoom:67%;" />

<p>Alice的用户代理用SMTP或HTTP将电子邮件报文推入她的邮件服务器，接着她的邮件服务器（作为一个SMTP客户）再用SMTP将该邮件中继（推）到Bob的邮件服务器。</p>
<p>这个过程分成两部：因为不通过Alice的邮件服务器进行中继，Alice的用户代理将没有任何办法到达一个不可达的目的地邮件服务器。通过首先将邮件存放在自己邮件服务器中，Alice的邮件服务器可以重复地尝试向Bob的邮件服务器发送该报文，如每30分钟一次，知道Bob的邮件服务器变得运行为止。（如果Alice的服务器关机，则她能向系统管理员进行申告！）</p>
<ul>
<li>SMTP：传送到接收方的邮件服务器，SMTP是一个推协议。</li>
<li>邮件访问协议：从服务器访问邮件<ul>
<li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul>
<li>用户身份确认（代理 &lt;–&gt;服务器）并下载</li>
</ul>
</li>
<li>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730]<ul>
<li>更多特性（更复杂）</li>
<li>在服务器上处理存储的报文</li>
</ul>
</li>
<li>HTTP：Hotmail，Yahoo！Mail等<ul>
<li>方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="POP3与IMAP"><a href="#POP3与IMAP" class="headerlink" title="POP3与IMAP"></a>POP3与IMAP</h3><h4 id="POP3（本地管理文件夹）"><a href="#POP3（本地管理文件夹）" class="headerlink" title="POP3（本地管理文件夹）"></a>POP3（本地管理文件夹）</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602220959796.png" alt="image-20230602220959796" style="zoom:67%;" />

<ul>
<li>先前的例子使用 ”下载并删除” 模式。<ul>
<li>如果改变客户机，Bob不能阅读邮件</li>
</ul>
</li>
<li>“下载并保留” ：不同客户机上为报文的拷贝</li>
<li>POP3在会话中是无状态的</li>
</ul>
<h4 id="IMAP（因特网邮件访问协议）"><a href="#IMAP（因特网邮件访问协议）" class="headerlink" title="IMAP（因特网邮件访问协议）"></a>IMAP（因特网邮件访问协议）</h4><ul>
<li>IMAP服务器将每个报文与一个文件夹联系起来</li>
<li>允许用户用目录来组织报文</li>
<li>允许用户读取报文组件</li>
<li>IMAP在会话过程中保留用户状态：<ul>
<li>目录名、报文ID与目录名之间映射</li>
</ul>
</li>
</ul>
<blockquote>
<p>POP3和IMAP是两种在计算机网络中用于电子邮件接收的协议，它们可以实现将邮件从服务器上下载到本地计算机。POP3和IMAP的主要区别在于邮件的存储方式和访问方式。</p>
<p>POP3（Post Office Protocol Version 3）协议是一种将电子邮件从邮件服务器下载到本地计算机的协议，它支持在本地计算机上保存邮件，并可以离线访问已经下载的邮件。POP3协议的主要特点是简单和高效，它可以快速地将邮件下载到本地计算机，并且不需要保持与邮件服务器的连接。但是，POP3协议不支持在多台设备上同步访问邮件，也不支持对邮件进行标记、归档等操作。</p>
<p>IMAP（Internet Message Access Protocol）协议是一种在邮件服务器上直接操作邮件的协议，它支持在多台设备之间同步访问邮件，并且可以对邮件进行标记、归档等操作。IMAP协议的主要特点是灵活和高级，它可以在多台设备之间同步访问邮件，并且可以对邮件进行更多的操作。但是，IMAP协议需要保持与邮件服务器的连接，并且邮件数据存储在邮件服务器上，需要对邮件服务器进行定期备份和维护。</p>
<p>在使用电子邮件时，选择POP3或IMAP协议需要根据实际需求进行选择。如果需要在本地计算机上保存邮件，并且只在一台设备上访问邮件，可以选择POP3协议；如果需要在多台设备之间同步访问邮件，并且需要对邮件进行标记、归档等操作，可以选择IMAP协议。</p>
<p>总之，POP3和IMAP是两种在计算机网络中用于电子邮件接收的协议，它们具有不同的特点和用途，在使用电子邮件时需要根据实际需求进行选择。</p>
</blockquote>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（域名系统）服务器通常是运行BIND软件的UNIX机器，DNS协议运行在UDP之上，使用53号端口。</p>
<p>DNS是：</p>
<ol>
<li>一个由分层的 <strong>DNS服务器</strong>实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ol>
<h3 id="DNS（Domain-Name-System）"><a href="#DNS（Domain-Name-System）" class="headerlink" title="DNS（Domain Name System）"></a>DNS（Domain Name System）</h3><p>DNS的必要性</p>
<ul>
<li><p>IP地址标识主机、路由器</p>
</li>
<li><p>但IP地址不好记忆，不便人类使用（没有意义）</p>
</li>
<li><p>人类一般倾向于使用一些有意义的字符串来标识 Internet 上的设备</p>
<p>例如：<a href="mailto:&#x71;&#122;&#104;&#x65;&#110;&#x67;&#x40;&#x75;&#115;&#116;&#99;&#x2e;&#101;&#100;&#x75;">&#x71;&#122;&#104;&#x65;&#110;&#x67;&#x40;&#x75;&#115;&#116;&#99;&#x2e;&#101;&#100;&#x75;</a>..cn所在的邮件服务器</p>
<p>​			<a target="_blank" rel="noopener" href="http://www.ustc.edu.cn所在web服务器/">www.ustc.edu.cn所在web服务器</a></p>
</li>
<li><p>存在着 ”字符串“ — IP地址的转换的必要性</p>
</li>
<li><p>人类用户提供要访问机器的 ”字符串“ 名称</p>
</li>
<li><p>由DNS负责转换成为二进制的网络地址</p>
</li>
</ul>
<h3 id="DNS系统需要解决的问题"><a href="#DNS系统需要解决的问题" class="headerlink" title="DNS系统需要解决的问题"></a>DNS系统需要解决的问题</h3><p><strong>问题1：如何命名设备</strong></p>
<ul>
<li>用有意义的字符串：好记，便于人类使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
<p><strong>问题2：如何完成名字到IP地址的转换</strong></p>
<ul>
<li>分布式的数据库维护的响应名字查询</li>
</ul>
<p><strong>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</strong></p>
<h3 id="DNS的历史"><a href="#DNS的历史" class="headerlink" title="DNS的历史"></a>DNS的历史</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602222311740.png" alt="image-20230602222311740" style="zoom: 50%;" /> 

<h3 id="DNS总体思路和目标"><a href="#DNS总体思路和目标" class="headerlink" title="DNS总体思路和目标"></a>DNS总体思路和目标</h3><p>DNS通常是由其他应用层协议所使用的，包括HTTP和SMTP，将用户提供的主机名解析为IP地址。</p>
<p>用户主机将一个HTTP请求报文发送到Web服务器<a href="http://www.someschool.edu，该用户主机必须获得www.someschool.edu的IP地址。做法如下：">www.someschool.edu，该用户主机必须获得www.someschool.edu的IP地址。做法如下：</a></p>
<ol>
<li>同一台用户主机上运行着DNS应用的客户端。</li>
<li>浏览器从上述URL中抽取出主机名<a target="_blank" rel="noopener" href="http://www.someschool.edu,并将主机名传给dns应用的客户端./">www.someschool.edu，并将主机名传给DNS应用的客户端。</a></li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户最终会收到来自DNS的该IP地址，它就向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</li>
</ol>
<h4 id="DNS的主要思路"><a href="#DNS的主要思路" class="headerlink" title="DNS的主要思路"></a>DNS的主要思路</h4><ul>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上的端口号为53的应用服务</li>
<li>核心的 Internet 功能，但以应用层协议实现<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ul>
<h4 id="DNS主要目的"><a href="#DNS主要目的" class="headerlink" title="DNS主要目的"></a>DNS主要目的</h4><ul>
<li><p>实现主机名-IP地址的转换（name&#x2F;IP translate）</p>
</li>
<li><p>其它目的</p>
<ul>
<li><p><font color='red'>主机别名</font>到<font color='red'>规范名字</font>的转换：Host aliasing</p>
<p>应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址</p>
</li>
<li><p>邮件服务器<font color='red'>别名</font>到邮件服务器的<font color='red'>正规名字</font>的转换：Mail server aliaing</p>
</li>
<li><p><font color='red'><strong>负载均衡：</strong></font>Load Distribution</p>
</li>
</ul>
</li>
</ul>
<h3 id="问题1：DNS名字空间"><a href="#问题1：DNS名字空间" class="headerlink" title="问题1：DNS名字空间"></a>问题1：DNS名字空间</h3><h4 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h4><ul>
<li>一个层面命名设备会有很多重名</li>
<li>DNS采用层次树状结构的命名方法</li>
<li>Internet 跟被划为几百个顶级域（top lever domains）<ul>
<li>通用的（generic）<ul>
<li>.com</li>
<li>.edu</li>
<li>.gov</li>
<li>.firm</li>
</ul>
</li>
<li>国家的（countries）<ul>
<li>.cn</li>
<li>.us</li>
<li>.nl</li>
<li>.jp</li>
</ul>
</li>
</ul>
</li>
<li>每个（子）域下面可划分为若干子域（subdomains）</li>
<li>树叶是主机</li>
</ul>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602223825695.png" alt="image-20230602223825695"></p>
<p><strong>域名（Domain Name）</strong></p>
<ul>
<li><p>从本域往上，直到树根</p>
</li>
<li><p>中间使用 点（.）间隔不同的级别</p>
</li>
<li><p>例如：ustc.edu.cn</p>
<p>​			auto.ustc.edu.cn</p>
<p>​			<a target="_blank" rel="noopener" href="http://www.auto.ustc.edu.cn/">www.auto.ustc.edu.cn</a></p>
</li>
<li><p>域的域名：可以用于表示一个域</p>
</li>
<li><p>主机的域名：一个域上的一个主机</p>
</li>
</ul>
<p><strong>域名的管理</strong></p>
<ul>
<li>一个域管理其下的子域<ul>
<li>.jp 被划分为 ac.jp   co.jp</li>
<li>.cn  被划分为  edu.cn   com.cn</li>
</ul>
</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
<p><strong>域与物理网络无关</strong></p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
<h4 id="DNS：根名字服务器"><a href="#DNS：根名字服务器" class="headerlink" title="DNS：根名字服务器"></a>DNS：根名字服务器</h4><p><strong>根名字服务器提供TLD（顶级域）服务器的IP地址。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602223255305.png" alt="image-20230602223255305"></p>
<h3 id="问题2：解析问题-名字服务器"><a href="#问题2：解析问题-名字服务器" class="headerlink" title="问题2：解析问题-名字服务器"></a>问题2：解析问题-名字服务器</h3><p><strong>一个名字服务器的问题</strong></p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
<p><strong>区域（zone）</strong></p>
<ul>
<li>区域的划分有区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器：<ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息（authoritative record）</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
<h4 id="名字空间划分为若干区域：Zone"><a href="#名字空间划分为若干区域：Zone" class="headerlink" title="名字空间划分为若干区域：Zone"></a>名字空间划分为若干区域：Zone</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602224922897.png" alt="image-20230602224922897"></p>
<p><font color='red'><strong>权威DNS服务器：</strong></font>组织机构的DNS服务器，提供组织机构服务器（如Web 和 mail）可访问的主机和IP之间的映射</p>
<p>组织机构可以选择实现自己维护或由某个服务提供商来维护</p>
<h3 id="TLD服务器"><a href="#TLD服务器" class="headerlink" title="TLD服务器"></a>TLD服务器</h3><p><font color='red'><strong>顶级域（TLD）服务器：</strong></font>负责顶级域名（如com，org，net，edu和gov）和所有国家级的顶级域名（如cn，uk，fr，ca，jp）</p>
<ul>
<li>Network solutions 公司维护 com TLD 服务器</li>
<li>Educause 公司维护 edu TLD 服务器</li>
</ul>
<p><strong>TLD服务器提供了权威DNS服务器的IP地址。</strong></p>
<h4 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a>区域名字服务器维护资源记录</h4><p><strong>资源记录（resource records）</strong></p>
<ul>
<li>作用：维护 域名-IP地址（其他）的映射关系</li>
<li>位置：Name Server 的分布式数据库中</li>
</ul>
<p><strong>RR格式：</strong> （domain_name，ttl，type，class，Value）</p>
<ul>
<li>Domain_name：域名</li>
<li>Ttl：time to live：生存时间（权威，缓冲记录）</li>
<li>Class 类别：对于Internet，值为IN</li>
<li>Value 值：可以是数字，域名或ASCII串</li>
<li>Type 类别：资源记录的类型</li>
</ul>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong> 。</p>
<p><font color='red'><strong>DNS：</strong></font>保存资源记录（RR）的分布式数据库</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602225749167.png" alt="image-20230602225749167" style="zoom:67%;" /> 

<p><font color='red'><strong>TTL：</strong></font>生存时间，用于控制DNS缓存的机制，可以指定DNS记录在缓存中存留的时间，超过这个事件后，DNS记录就会过期并从缓存中删除。</p>
<h3 id="DNS大致工作过程"><a href="#DNS大致工作过程" class="headerlink" title="DNS大致工作过程"></a>DNS大致工作过程</h3><ul>
<li>应用调用 解析器（resolver）</li>
<li>解析器作为客户 向 Name Server 发出查询报文（封装在UDP段中）</li>
<li>Name Server 返回响应报文（name&#x2F;ip）</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602230953277.png" alt="image-20230602230953277" style="zoom:50%;" />

<h3 id="名字服务器"><a href="#名字服务器" class="headerlink" title="名字服务器"></a>名字服务器</h3><h4 id="本地名字服务器（Local-Name-Server）"><a href="#本地名字服务器（Local-Name-Server）" class="headerlink" title="本地名字服务器（Local Name Server）"></a>本地名字服务器（Local Name Server）</h4><ul>
<li>并不严格属于层次结构</li>
<li>每个ISP（居民区的ISP、公司、大学）都有一个本地DNS服务器<ul>
<li>也称为 “默认名字服务器”</li>
</ul>
</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器<ul>
<li>起着代理作用，将查询转发到层次结构中</li>
</ul>
</li>
</ul>
<h4 id="名字服务器（Name-Server）"><a href="#名字服务器（Name-Server）" class="headerlink" title="名字服务器（Name Server）"></a>名字服务器（Name Server）</h4><p><strong>名字解析过程</strong></p>
<ul>
<li>目标名字在 Local Name Server 中<ul>
<li>情况1：查询的名字在该区域内部</li>
<li>情况2：缓存（cashing）</li>
</ul>
</li>
</ul>
<p>当与本地名字服务器不能解析名字时，联系根名字服务器顺着 <strong>根 - TLD</strong> 一直找到 <strong>权威名字服务器</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602231502053.png" alt="image-20230602231502053" style="zoom: 50%;" />

<h3 id="通过主机名查询其IP地址"><a href="#通过主机名查询其IP地址" class="headerlink" title="通过主机名查询其IP地址"></a>通过主机名查询其IP地址</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p><font color='red'><strong>递归查询：</strong></font></p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上<ul>
<li>问题：根服务器的负担太重</li>
<li>解决：迭代查询（iterated queries）</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602231707413.png" alt="image-20230602231707413" style="zoom: 50%;" />

<p><font color='red'><strong>本地DNS服务器：</strong></font>当主机发送DNS请求时，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。</p>
<blockquote>
<p>本地DNS服务器是指一种在本地计算机上运行的DNS服务器，它可以加快域名解析的速度并提高域名解析的准确性。</p>
<p>DNS（Domain Name System）是一种将域名和IP地址相互映射的分布式数据库系统。当我们在浏览器中输入一个域名时，浏览器会向本地DNS服务器发起查询请求，本地DNS服务器会查询缓存或者向其他DNS服务器发起查询请求，最终将域名解析成IP地址并返回给浏览器，浏览器再通过IP地址访问对应的网站。</p>
<p>使用本地DNS服务器可以加快域名解析的速度，因为本地DNS服务器通常会缓存已解析的域名和IP地址，当再次访问已缓存的域名时，本地DNS服务器可以直接返回缓存中的IP地址，不需要再向其他DNS服务器发起查询请求。同时，本地DNS服务器还可以提高域名解析的准确性，因为它可以通过配置本地DNS记录来实现自定义的域名解析。</p>
<p>搭建本地DNS服务器需要安装DNS服务器软件，并进行相应的配置。常见的DNS服务器软件有BIND、dnsmasq等。在配置DNS服务器时，需要设置本地DNS记录、转发DNS请求等参数，以实现本地DNS服务器的功能。</p>
<p>总之，本地DNS服务器是一种可以加快域名解析速度并提高解析准确性的DNS服务器，可以通过安装DNS服务器软件并进行相应配置来实现。</p>
</blockquote>
<h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>主机 cis.poly.edu 想知道主机 gaia.cs.umass.edu 的IP地址</p>
<ul>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系服务器的名字</li>
<li>”我不知道这个名字，但可以向这个服务器请求“</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230602232130704.png" alt="image-20230602232130704" style="zoom:50%;" />

<h3 id="DNS协议、报文"><a href="#DNS协议、报文" class="headerlink" title="DNS协议、报文"></a>DNS协议、报文</h3><p>DNS协议：<font color='red'>查询</font>和<font color='red'>响应</font>报文的<font color='red'>报文格式</font>相同</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603082756617.png" alt="image-20230603082756617" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603082839939.png" alt="image-20230603082839939" style="zoom:67%;" />

<h3 id="提高性能：缓存"><a href="#提高性能：缓存" class="headerlink" title="提高性能：缓存"></a>提高性能：缓存</h3><p>DNS缓存：为了改善时延性能并减少在因特网上到处传输的DNS报文数量</p>
<ul>
<li>一旦名字服务器得到了一个映射，就将该映射<font color='red'>缓存</font>起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案：TTL（默认2天）</li>
<li>由于主机和主机明明与IP地址间的映射并不是永久的，DNS服务器在一段时间后（通常设置为2天）将丢弃缓存的信息。</li>
</ul>
<h3 id="问题3：维护问题：新增一个域"><a href="#问题3：维护问题：新增一个域" class="headerlink" title="问题3：维护问题：新增一个域"></a>问题3：维护问题：新增一个域</h3><ul>
<li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</p>
</li>
<li><p>在新增子域 的 名字服务器上运行名字服务器，负责本域的名字解析：名字 –&gt; IP地址</p>
<p>例子：在com域中建立一个 “Network Utopia”</p>
</li>
<li><p>到注册等级机构注册域名 networkutopia.com</p>
<ul>
<li><p>需要向该机构提供权威DNS服务器（基本的、辅助的）的名字和IP地址</p>
</li>
<li><p>等级机构在 com  TLD 服务器中插入两条 RR 记录：</p>
<p>（networkutopia.com，dns1.networkutopia.com，NS）</p>
<p>（dns1.networkutopia.com，212.212.212.1，A）</p>
</li>
</ul>
</li>
<li><p>在networkuto pia.com的权威服务器中确保有</p>
<ul>
<li>用于Web服务器的 <a target="_blank" rel="noopener" href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li>
<li>用于邮件服务器的mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<h3 id="攻击DNS"><a href="#攻击DNS" class="headerlink" title="攻击DNS"></a>攻击DNS</h3><h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ul>
<li>对根服务器进行流量轰炸攻击：发送大量ping<ul>
<li>没有成功</li>
<li>原因1：根目录服务器配置了流量过滤器，防火墙</li>
<li>原因2：本地 DNS 服务器缓存了TLD服务器的IP地址，因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击：发送大量查询<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>总的来说：DNS比较健壮</strong></font></p>
<blockquote>
<p>DDOS（Distributed Denial of Service）攻击是一种利用多台计算机对目标计算机发起攻击的网络攻击行为。DDOS攻击旨在通过占用目标计算机的网络带宽和系统资源，使其无法正常提供服务或访问网络。</p>
<p>DDOS攻击通常使用大量的控制计算机和代理计算机，通过向目标计算机发送大量的请求或数据包，占用其网络带宽和系统资源，导致目标计算机无法正常工作。DDOS攻击可以采用多种方式进行，包括流量攻击、协议攻击、应用层攻击等。</p>
<p>流量攻击是一种通过向目标计算机发送大量的网络流量来占用其网络带宽和系统资源的攻击方式。流量攻击通常使用大量的控制计算机和代理计算机，通过向目标计算机发送大量的请求或数据包，使其无法正常响应。流量攻击可以采用多种方式进行，包括UDP Flood、TCP SYN Flood、ICMP Flood等。</p>
<p>协议攻击是一种通过向目标计算机发送大量的协议请求来占用其网络带宽和系统资源的攻击方式。协议攻击通常使用大量的控制计算机和代理计算机，通过向目标计算机发送大量的协议请求，使其无法正常处理和响应。协议攻击可以针对不同的协议进行，包括DNS协议、NTP协议、SMTP协议等。</p>
<p>应用层攻击是一种通过向目标计算机发送恶意的应用层请求来占用其网络带宽和系统资源的攻击方式。应用层攻击通常针对特定的应用程序进行，通过向目标计算机发送大量的恶意请求，使其无法正常处理和响应。应用层攻击可以采用多种方式进行，包括HTTP请求攻击、HTTPS请求攻击、DNS请求攻击等。</p>
<p>为了防止DDOS攻击，需要采取一系列的安全措施，包括增强网络安全防护、优化网络架构、配置防火墙和入侵检测系统、使用CDN和云防护等。同时，还需要进行合理的容灾和备份，以确保在遭受DDOS攻击时可以快速恢复服务。</p>
<p>总之，DDOS攻击是一种危害性很大的网络攻击行为，可以采用多种方式进行。为了防止DDOS攻击，需要采取一系列的安全措施和应急措施，以确保网络安全和服务可靠。</p>
</blockquote>
<h4 id="重定向攻击"><a href="#重定向攻击" class="headerlink" title="重定向攻击"></a>重定向攻击</h4><ul>
<li>中间人攻击<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li>DNS中毒<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获和伪造</li>
</ul>
<p><strong>利用DNS基础设施进行DDOS</strong></p>
<ul>
<li>伪造某个IP进行查询，攻击这个目标IP</li>
<li>查询放大，响应报文比查询报文大</li>
<li>效果有限</li>
</ul>
<blockquote>
<p>重定向攻击（DNS Spoofing）是一种网络攻击行为，攻击者会伪装成DNS服务器，向目标计算机发送虚假的DNS响应，将域名解析到错误的IP地址上。这种攻击行为可能会导致用户被重定向到恶意网站或者无法访问正常网站，从而造成严重的安全风险和损失。</p>
<p>为了防止重定向攻击，可以采取一系列的安全措施，包括：</p>
<ol>
<li><p>使用DNSSEC（DNS Security Extensions）协议，该协议可以对DNS查询和响应进行数字签名和验证，防止DNS响应被篡改。</p>
</li>
<li><p>配置防火墙和入侵检测系统，对DNS查询和响应进行监控和过滤，防止伪造的DNS响应进入网络。</p>
</li>
<li><p>使用DNS缓存服务器，对DNS查询结果进行缓存和定期更新，减少DNS查询量和降低被攻击的风险。</p>
</li>
<li><p>更新操作系统和应用程序的安全补丁，以修复可能存在的DNS漏洞和安全漏洞。</p>
</li>
</ol>
<p>总之，重定向攻击是一种危害性很大的网络攻击行为，可以采取多种安全措施来防范和减轻攻击的影响。</p>
</blockquote>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><h3 id="纯P2P架构"><a href="#纯P2P架构" class="headerlink" title="纯P2P架构"></a>纯P2P架构</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603090233273.png" alt="image-20230603090233273" style="zoom:50%;" />

<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li>文件分发（BitTorrent）</li>
<li>流媒体（KanKan）</li>
<li>VoIP（Skype）</li>
</ul>
<p>使用了P2P体系结构，对总是打开的基础设施服务器依赖最少（或者没有依赖）。与之相反，成对间歇连接的主机（称为对等方）彼此直接通信。</p>
<h3 id="文件分发：C-x2F-S-vs-P2P"><a href="#文件分发：C-x2F-S-vs-P2P" class="headerlink" title="文件分发：C&#x2F;S vs P2P"></a>文件分发：C&#x2F;S vs P2P</h3><p><strong>分发时间</strong>：所有N个对等方得到该文件的副本所需要的时间。</p>
<p><font color='red'><strong>问题：</strong></font>从一台服务器分发文件（大小F）到N个peer需要多少时间？</p>
<ul>
<li><p>Peer节点上下载能力是有限的资源</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230506213711975.png" alt="image-20230506213711975" style="zoom:67%;" /></li>
</ul>
<p>文件分发时间：C&#x2F;S 模式</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230506213917873.png" alt="image-20230506213917873" style="zoom: 67%;" />

<p><font color='red'><strong>服务器传输：</strong></font>都是由服务器发送给 peer，服务器必须顺序传输（上载）N个文件拷贝：</p>
<ul>
<li>发送一个 copy：F&#x2F;us</li>
<li>发送N个 copy：NF&#x2F;us</li>
</ul>
<p><font color='red'><strong>客户端：</strong></font>每个客户端必须下载一个文件拷贝</p>
<ul>
<li>d(min) &#x3D; 客户端最小的下载速率</li>
<li>下载带宽最小的客户端下载的时间：F&#x2F;d(min)</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603090936352.png" alt="image-20230603090936352" style="zoom:67%;" />

<h3 id="文件分发时间：P2P模式"><a href="#文件分发时间：P2P模式" class="headerlink" title="文件分发时间：P2P模式"></a>文件分发时间：P2P模式</h3><p><font color='red'><strong>服务器传输：</strong></font>最少需要上载一份拷贝</p>
<ul>
<li>发送一个拷贝的时间：F&#x2F;us</li>
</ul>
<p><font color='red'><strong>客户端：</strong></font>每个客户端必须下载一个拷贝</p>
<ul>
<li>最小下载带宽客户单耗时：F&#x2F;d(min)</li>
</ul>
<p><font color='red'><strong>客户端：</strong></font>所有客户端总体总体下载量NF</p>
<ul>
<li><p>最大的上载带宽是  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230506214751815.png" alt="image-20230506214751815" style="zoom: 50%;" /> 
</li>
<li><p>除了服务器可以上载，其他所有的 peer 节点都可以上载</p>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603091815084.png" alt="image-20230603091815084" style="zoom:80%;" />

<p>因此：具有P2P体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是：对等方除了是比特的消费者外还是它们的重新分发者。</p>
<p><strong>例子：</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603091912661.png" alt="image-20230603091912661" style="zoom:67%;" />

<h3 id="P2P文件分发：BitTorrent"><a href="#P2P文件分发：BitTorrent" class="headerlink" title="P2P文件分发：BitTorrent"></a>P2P文件分发：BitTorrent</h3><ul>
<li>文件被分为一个个块 256KB</li>
<li>网络中的这些peers发送接收文件块，相互服务</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603092031760.png" alt="image-20230603092031760" style="zoom:67%;" />

<ul>
<li>Peer加入torrent：<ul>
<li>一开始没有块，但是将会通过其他节点处累计文件块</li>
<li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系（“连接”）</li>
</ul>
</li>
<li>当peer下载时，该peer可以同时向其他节点提供上载服务</li>
<li>Peer可能会变换用于交换块的peer节点</li>
<li><font color='red'><strong>扰动churn：</strong></font>peer节点可能会上线或者下线</li>
<li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li>
</ul>
<blockquote>
<p>BitTorrent协议的工作原理如下：</p>
<ol>
<li>发布种子文件：文件上传者需要将待传输的文件制作成种子文件，并发布到公开的种子服务器上，以便其他用户可以通过种子文件下载待传输的文件。</li>
<li>下载种子文件：其他用户可以通过P2P客户端下载种子文件，并通过种子文件获取待传输文件的信息和下载地址。</li>
<li>下载文件块：用户通过P2P客户端连接其他用户，根据文件块的需求和可用性，从其他用户处下载文件块，并在自己的计算机上保存。</li>
<li>分享文件块：下载完成的用户可以将自己的文件块上传给其他需要的用户，以帮助其他用户更快地下载文件。BitTorrent协议会优先选择上传速度较快的用户进行文件块的上传。</li>
</ol>
<p>通过BitTorrent协议进行P2P文件分发可以有效地提高文件传输和分发的速度和效率，同时可以降低单个上传者和下载者的带宽和资源消耗。但是，P2P文件分发也存在一些风险和安全隐患，如版权侵犯、恶意软件传播等问题，需要注意相应的安全措施和风险管理。</p>
</blockquote>
<h3 id="BitTorrent：请求，发送文件块"><a href="#BitTorrent：请求，发送文件块" class="headerlink" title="BitTorrent：请求，发送文件块"></a>BitTorrent：请求，发送文件块</h3><p><font color='red'><strong>请求块：</strong></font></p>
<ul>
<li>在任何给定时间，不同peer节点拥有一个文件块的自己</li>
<li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li>
<li>Alice向peer节点请求它希望的块，稀缺的块</li>
</ul>
<p><font color='red'><strong>发送块：一报还一报 tit-for-tat</strong></font></p>
<ul>
<li>Alice向4个peer发送块，这些块向他自己提供最大带宽的服务<ul>
<li>其他peer被Alice阻塞（将不会从Alice处获得服务）</li>
<li>每10秒重新评估一次：前4位</li>
</ul>
</li>
<li>每个30秒：随机选择其他peer节点，想这个节点发送块<ul>
<li>“优化疏通” 这个节点</li>
<li>新选择的节点可以加入这个top4</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603093202171.png" alt="image-20230603093202171" style="zoom:67%;" />

<h3 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a>P2P文件共享</h3><p>例子：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603093241277.png" alt="image-20230603093241277" style="zoom: 50%;" />

<p><font color='red'><strong>两大问题：</strong></font></p>
<ul>
<li>如何定位所需资源</li>
<li>如何处理对等方的加入与离开</li>
</ul>
<p><strong>可能的方案</strong></p>
<ul>
<li>集中</li>
<li>分散</li>
<li>半分散</li>
</ul>
<h3 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a>P2P：集中式目录</h3><p>最初的 “Napster” 设计</p>
<ol>
<li>当对等方连接时，它告知中心服务器<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
</li>
<li>Alice查询 “双节棍.MP3”</li>
<li>Alice从Bob处请求文件</li>
</ol>
<p><strong>集中式目录存在的问题</strong></p>
<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<p>文件传输是分散的，而定位内容则是高度集中的</p>
<h3 id="查询洪泛：Gnutella"><a href="#查询洪泛：Gnutella" class="headerlink" title="查询洪泛：Gnutella"></a>查询洪泛：Gnutella</h3><ul>
<li>全分布式<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多Gnutella客户端实现了Gnutella协议<ul>
<li>类似HTTP有许多的浏览器</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>覆盖网络：图</strong></font></p>
<ul>
<li>如果X和Y之间有一个TCP连接，则二者之间存在一条边</li>
<li>所有活动的对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于10个</li>
</ul>
<h4 id="Gnutella：协议"><a href="#Gnutella：协议" class="headerlink" title="Gnutella：协议"></a>Gnutella：协议</h4><ul>
<li>在已有的TCP的连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
<p><font color='red'><strong>可扩展性：</strong></font>限制范围的洪泛查询</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603094425228.png" alt="image-20230603094425228" style="zoom:50%;" />

<h4 id="Gnutella：对等方加入"><a href="#Gnutella：对等方加入" class="headerlink" title="Gnutella：对等方加入"></a>Gnutella：对等方加入</h4><ol>
<li>对等方X必须首先发现某些已经在覆盖网络中的其他对等方：使用可用对等方列表<ul>
<li>自己维持一张对等方列表（经常开机的对等方的IP）</li>
<li>联系维持列表的Gnutella站点</li>
</ul>
</li>
<li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</li>
<li>X向Y发送一个Ping报文，Y转发该Ping报文</li>
<li>所有收到Ping报文的对等方以Pong报文响应 IP地址、共享文件的数量及总字节数</li>
<li>X收到许多Pong报文，然后它能建立其他TCP连接</li>
</ol>
<blockquote>
<p>Gnutella是一种基于P2P协议的文件共享网络，可以在不依赖中心服务器的情况下，实现用户之间的文件共享和传输。Gnutella协议采用分布式查询和资源发现机制，用户可以通过Gnutella网络搜索和下载其他用户共享的文件。</p>
<p>Gnutella协议的工作原理如下：</p>
<ol>
<li><p>用户加入网络：用户通过Gnutella客户端加入Gnutella网络，并与其他用户建立连接。</p>
</li>
<li><p>分布式查询：用户可以通过Gnutella客户端向其他用户发送查询请求，搜索其他用户共享的文件。查询请求会在Gnutella网络中分布式传播和扩散，直到找到匹配的文件资源。</p>
</li>
<li><p>文件下载：用户可以通过Gnutella客户端从其他用户处下载文件，并在自己的计算机上保存。文件下载过程也是基于P2P协议进行的，用户可以从多个上传者处同时下载文件块，以提高下载速度和效率。</p>
</li>
</ol>
<p>通过Gnutella协议进行P2P文件共享和传输具有很大的优势，可以实现高速的文件传输和广泛的文件共享。但是，Gnutella网络也存在一些问题和隐患，如版权侵犯、恶意软件传播等问题，需要注意相应的安全措施和风险管理。</p>
<p>总之，Gnutella是一种基于P2P协议的文件共享网络，可以实现用户之间的文件共享和传输，具有很大的优势和潜力。</p>
</blockquote>
<h3 id="KaZaA"><a href="#KaZaA" class="headerlink" title="KaZaA"></a>KaZaA</h3><h4 id="利用不匀称性：KaZaA"><a href="#利用不匀称性：KaZaA" class="headerlink" title="利用不匀称性：KaZaA"></a>利用不匀称性：KaZaA</h4><ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长<ul>
<li>对等方与其组长之间有TCP连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长联系<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603095331358.png" alt="image-20230603095331358" style="zoom: 50%;" />

<h4 id="KaZaA：查询"><a href="#KaZaA：查询" class="headerlink" title="KaZaA：查询"></a>KaZaA：查询</h4><ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应：<ul>
<li><font color='red'>对每个匹配：元数据、散列标识码和IP地址</font></li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长也以匹配进行响应</li>
<li>客户端选择要下载的文件<ul>
<li><font color='red'>向拥有文件的对等方发送一个带散列标识码的HTTP请求</font></li>
</ul>
</li>
</ul>
<h4 id="KaZaA小技巧"><a href="#KaZaA小技巧" class="headerlink" title="KaZaA小技巧"></a>KaZaA小技巧</h4><ul>
<li>请求排队<ul>
<li>限制并行上载的数量</li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽</li>
</ul>
</li>
<li>激励优先权<ul>
<li>鼓励用户上载文件</li>
<li>加强系统的扩展性</li>
</ul>
</li>
<li>并行下载<ul>
<li>从多个对等方下载同一个文件的不同部分<ul>
<li>HTTP的字节范围首部</li>
<li>更快地检索一个文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>KaZaA是一款P2P文件共享软件，是早期P2P文件共享软件中的一种。KaZaA采用了类似Gnutella的分布式查询和资源发现机制，用户可以通过KaZaA客户端搜索和下载其他用户共享的文件。</p>
<p>KaZaA的工作原理如下：</p>
<ol>
<li><p>用户加入网络：用户通过KaZaA客户端加入KaZaA网络，并与其他用户建立连接。</p>
</li>
<li><p>分布式查询：用户可以通过KaZaA客户端向其他用户发送查询请求，搜索其他用户共享的文件。查询请求会在KaZaA网络中分布式传播和扩散，直到找到匹配的文件资源。</p>
</li>
<li><p>文件下载：用户可以通过KaZaA客户端从其他用户处下载文件，并在自己的计算机上保存。KaZaA客户端支持多线程下载，用户可以从多个上传者处同时下载文件块，以提高下载速度和效率。</p>
</li>
</ol>
<p>KaZaA曾经是非常受欢迎的P2P文件共享软件之一，但是由于它的版权侵犯和恶意软件传播等问题，已经逐渐退出了市场。目前，类似KaZaA的P2P文件共享软件依然存在，但是它们面临着各种各样的安全和法律问题，需要注意相应的风险管理和安全措施。</p>
<p>总之，KaZaA是一款早期的P2P文件共享软件，采用了类似Gnutella的分布式查询和资源发现机制，可以实现用户之间的文件共享和传输。</p>
</blockquote>
<h3 id="Distributed-Hash-Table（DHT）"><a href="#Distributed-Hash-Table（DHT）" class="headerlink" title="Distributed Hash Table（DHT）"></a>Distributed Hash Table（DHT）</h3><ul>
<li>哈希表</li>
<li>DHT方案</li>
<li>环形DHT  以及覆盖网络</li>
<li>Peer波动</li>
</ul>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="视频流化服务和CDN"><a href="#视频流化服务和CDN" class="headerlink" title="视频流化服务和CDN"></a>视频流化服务和CDN</h3><h4 id="视频流化服务和CDN：上下文"><a href="#视频流化服务和CDN：上下文" class="headerlink" title="视频流化服务和CDN：上下文"></a>视频流化服务和CDN：上下文</h4><ul>
<li>视频流量：占据着互联网大部分的带宽<ul>
<li>Netfix，YouTube：占据37%，16%的ISP下行流量</li>
<li>~1B YouTube 用户：占据37%，16%的ISP下行流量</li>
</ul>
</li>
<li>挑战：规模性-如何服务者 ~1B用户？<ul>
<li>单个超级服务器无法提供服务（为什么）</li>
</ul>
</li>
<li>挑战：异构性<ul>
<li>不同用户拥有不同的能力（例如：有线接入和移动用户：带宽丰富和受限用户）</li>
</ul>
</li>
<li><font color='red'><strong>解决方案：</strong></font>分布式的，应用层面的基础设施</li>
</ul>
<h4 id="多媒体：视频"><a href="#多媒体：视频" class="headerlink" title="多媒体：视频"></a>多媒体：视频</h4><ul>
<li>视频：固定速度显示的图像序列<ul>
<li>e. g.  24 images&#x2F;sec</li>
</ul>
</li>
<li>网络视频特点：<ul>
<li>高码率： &gt;10x于音频，高的网络带宽需求</li>
<li>可以被压缩</li>
<li>90%以上的网络流量是视频</li>
</ul>
</li>
<li>数字化图像：像素的阵列<ul>
<li>每个像素被若干bits表示</li>
</ul>
</li>
<li>编码：使用图像内和图像间的冗余来降低编码的比特数<ul>
<li>空间冗余（图像内）</li>
<li>时间冗余（相邻的图像间）</li>
</ul>
</li>
<li><font color='red'><strong>CBR（constant bit rate）：</strong></font>以固定速率编码</li>
<li><font color='red'><strong>VBR（variable bit rate）：</strong></font>视频编码速率随时间的变化而变化</li>
<li>例子：<ul>
<li>MPEG 1 （CD-ROM） 1.5 Mbps</li>
<li>MPEG2（DVD） 3-6Mbps</li>
<li>MPEG4（often used in Internet，&lt; 1Mpbs）</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603102429418.png" alt="image-20230603102429418" style="zoom: 67%;" />

<h3 id="存储视频的流化服务："><a href="#存储视频的流化服务：" class="headerlink" title="存储视频的流化服务："></a>存储视频的流化服务：</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603102534437.png" alt="image-20230603102534437" style="zoom:67%;" />

<h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p>DASH允许客户使用不同的因特网接入速率流式播放具有不同编码速率的视频。</p>
<p>DASH允许客户自由地在不同的质量等级之间切换。</p>
<ul>
<li><p><font color='red'><strong>DASH：</strong></font>Dynamic，Adaptive Streaming over HTTP</p>
</li>
<li><p><strong>服务器：</strong></p>
<ul>
<li><p>将视频文件分割成多个块</p>
</li>
<li><p>每个块独立存储，编码于不同码率（8-10种）</p>
</li>
<li><p><font color='red'>告示文件（manifest file）：</font>提供不同块的URL</p>
</li>
</ul>
</li>
<li><p><strong>客户端：</strong></p>
<ul>
<li>先获取告示文件</li>
<li>周期性地测量服务器到客户端的带宽</li>
<li>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围<ul>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="流式多媒体技术3：DASH"><a href="#流式多媒体技术3：DASH" class="headerlink" title="流式多媒体技术3：DASH"></a>流式多媒体技术3：DASH</h4><ul>
<li>“智能” 客户端：客户端自适应决定<ul>
<li><font color='red'>什么时候</font>去请求块（不至于缓存挨饿，或者溢出）</li>
<li>请求<font color='red'>什么编码速率</font>的视频块（当带宽够用时，请求高质量的视频块）</li>
<li><font color='red'>哪里</font>去请求块（可以向离自己进的服务器发送URL，或者向高可用带宽的服务器请求）</li>
</ul>
</li>
</ul>
<h4 id="Content-Distribution-Networks-CDN"><a href="#Content-Distribution-Networks-CDN" class="headerlink" title="Content Distribution Networks (CDN)"></a>Content Distribution Networks (CDN)</h4><ul>
<li><p><font color='red'><strong>挑战：</strong></font>服务器如何通过网络向上百万用户同时流化视频内容（上百万视频内容）</p>
</li>
<li><p><font color='red'><strong>选项1：</strong></font>单个的、大的超级服务中心 “megaserver”</p>
<ul>
<li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿</li>
<li>“二八规律” 决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差）</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
<p><strong>评述：</strong>相当简单，但是这个方法<font color='red'>不可扩展</font></p>
</li>
<li><p><font color='red'><strong>选项2：</strong></font>通过<font color='red'><strong>CDN</strong></font>，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<ul>
<li>enter deep：将CDN服务器深入到许多接入网<ul>
<li>更接近用户，数量多，离用户近，管理困难</li>
<li>Akamai，1700个位置</li>
</ul>
</li>
<li>bring home：部署在少数（10个左右）关键位置，如将服务器簇安装于POP附近<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CDN管理分部在多个地理位置上的服务器，在它的服务器中存储视频的副本，并且所有视图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。</p>
<h4 id="Content-Distribution-Networks（CDNs）"><a href="#Content-Distribution-Networks（CDNs）" class="headerlink" title="Content Distribution Networks（CDNs）"></a>Content Distribution Networks（CDNs）</h4><ul>
<li>CDN：在CDN节点中存储内容的多个拷贝<ul>
<li>e. g.  Netflix stores copies of MadMen</li>
</ul>
</li>
<li>用户从CDN中请求内容<ul>
<li>重定向到最近的拷贝，请求内容</li>
<li>如果网络路径拥塞，可能选择不同的拷贝</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603104451321.png" alt="image-20230603104451321" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603104505251.png" alt="image-20230603104505251" style="zoom:67%;" />

<p><font color='red'><strong>OTT 挑战：</strong></font>在拥塞的互联网上复制内容</p>
<ul>
<li>从哪个CDN节点中获取内容？</li>
<li>用户在网络拥塞时的行为？</li>
<li>在哪些CDN节点中存储什么内容？</li>
</ul>
<h4 id="CDN：“简单”-内容访问场景"><a href="#CDN：“简单”-内容访问场景" class="headerlink" title="CDN：“简单” 内容访问场景"></a>CDN：“简单” 内容访问场景</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603104846867.png" alt="image-20230603104846867" style="zoom:67%;" />

<h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2><h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p>应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用</p>
<ul>
<li>TCP&#x2F;IP：应用进程使用 Socket API 访问传输服务</li>
<li>地点：界面上的SAP（Socket） 方式：Socket API</li>
</ul>
<p><font color='red'><strong>目标：</strong></font>学习如何构建能借助sockets进行通信的 C&#x2F;S 应用程序</p>
<p><font color='red'><strong>socket：</strong></font>分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603105138552.png" alt="image-20230603105138552" style="zoom:67%;" />

<p><font color='red'><strong>2种传输层服务的socket类型：</strong></font></p>
<ul>
<li>TCP：可靠的、字节流的服务</li>
<li>UDP：不可靠（数据UDP数据报）服务</li>
</ul>
<h3 id="TCP套接字编程-1"><a href="#TCP套接字编程-1" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><h4 id="TCP套接字编程-2"><a href="#TCP套接字编程-2" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h4><p><font color='red'><strong>套接字：</strong></font>应用进程与端到端传输协议（TCP或UDP）之间的门户</p>
<p><font color='red'><strong>TCP服务：</strong></font>从一个进程向另一个进程可靠地传输<font color='red'>字节流</font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603105414315.png" alt="image-20230603105414315" style="zoom:67%;" />

<p><font color='red'><strong>服务器首先运行，等待连接建立</strong></font></p>
<p><u>1：服务器进程必须先处于运行状态</u></p>
<ul>
<li><strong>创建</strong>欢迎socket</li>
<li>和本地端口<strong>捆绑</strong></li>
<li>在欢迎socket上阻塞式<strong>等待接收</strong>用户的连接</li>
</ul>
<p><font color='red'><strong>客户端主动和服务器建立连接：</strong></font></p>
<p><u>2.创建客户端本地套接字（**隐式捆绑 **到本地port）</u></p>
<ul>
<li>指定服务器进程的IP地址和端口号，与服务器进程<strong>连接</strong></li>
</ul>
<p>在创建该TCP连接时，我们将其与客户套接字地址（IP地址和端口号）和服务器套接字地址（IP地址和端口号）关联起来。</p>
<p><u>3.当与客户端连接请求的到来时</u></p>
<ul>
<li>服务器<strong>接收</strong>来自用户端的请求，解除阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口号来区分不同的客户端</li>
</ul>
</li>
</ul>
<blockquote>
<p>从应用程序的角度</p>
<p><font color='cornflowerblue'>TCP 在客户端与服务器进程之间提供了可靠的、字节流（管道）服务</font></p>
</blockquote>
<p><u>4.连接API调用有效时，客户端P与服务器建立了TCP连接</u></p>
<p>使用创建的TCP连接，当一侧要向另一侧发送数据时，它只需讲过其套接字将数据丢进TCP连接</p>
<h4 id="C-x2F-S-socket交互：TCP"><a href="#C-x2F-S-socket交互：TCP" class="headerlink" title="C&#x2F;S socket交互：TCP"></a>C&#x2F;S socket交互：TCP</h4>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603110752506.png" alt="image-20230603110752506" style="zoom:67%;" />

<h4 id="数据结构-sockaddr-in"><a href="#数据结构-sockaddr-in" class="headerlink" title="数据结构 sockaddr_in"></a>数据结构 sockaddr_in</h4><p><font color='red'><strong>IP地址和port捆绑关系的数据结构</strong></font>（标示进程的端节点）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603110949659.png" alt="image-20230603110949659" style="zoom: 50%;" />

<h4 id="数据结构-hostent"><a href="#数据结构-hostent" class="headerlink" title="数据结构 hostent"></a>数据结构 hostent</h4><p><font color='red'><strong>域名和IP地址的数据结构</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603111027626.png" alt="image-20230603111027626" style="zoom: 50%;" />

<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><strong>C客户端（TCP）</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603111217483.png" alt="image-20230603111217483"  />

<p><strong>C服务器</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603111402131.png" alt="image-20230603111402131"></p>
<h2 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h2><h3 id="UDP-Socket编程"><a href="#UDP-Socket编程" class="headerlink" title="UDP Socket编程"></a>UDP Socket编程</h3><p>应用程序开发者在套接字的应用层一侧可以控制所有东西，然而，它几乎无法控制运输层一侧。</p>
<p><font color='red'><strong>UDP：</strong></font><strong>在客户端和服务器之间没有连接</strong></p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地指定目标的IP地址和端口号</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和端口号</li>
</ul>
<p>将源地址附在分组之上通常并不是由UDP应用程序代码所为，而是由底层操作系统自动完成的。</p>
<blockquote>
<p>从 进程角度看 UDP 服务：</p>
<p>UDP 为 客户端和服务器端提供 不可靠的 字节组的传送服务</p>
<p><strong>UDP： 传送的数据可能 乱序，也可能丢失</strong></p>
</blockquote>
<h4 id="C-x2F-S-socket-交互：udp"><a href="#C-x2F-S-socket-交互：udp" class="headerlink" title="C&#x2F;S socket 交互：udp "></a>C&#x2F;S socket 交互：udp <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230506233639309.png" alt="image-20230506233639309"></h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230603111803161.png" alt="image-20230603111803161" style="zoom:50%;" />

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>应用程序体系结构<ul>
<li>客户-服务器</li>
<li>P2P</li>
<li>混合</li>
</ul>
</li>
<li>应用程序需要的服务品质描述<ul>
<li>可靠性</li>
<li>带宽</li>
<li>延时</li>
<li>安全</li>
</ul>
</li>
<li>Internet 传输层服务模式<ul>
<li>可靠的、面向连接的服务：TCP</li>
<li>不可靠的数据报：UDP</li>
</ul>
</li>
<li>流行的应用层协议：<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP、POP、IMAP</li>
<li>DNS</li>
</ul>
</li>
<li>Socket编程</li>
</ul>
<p><font color='red'><strong>更重要的：</strong></font><strong>学习协议的知识</strong></p>
<ul>
<li>应用层协议报文类型：请求&#x2F;响应报文：<ul>
<li>客户端请求信息或服务</li>
<li>服务器以数据、状态码进行响应</li>
</ul>
</li>
<li>报文格式：<ul>
<li>首部：关于数据信息的字段</li>
<li>数据：被交换的信息</li>
</ul>
</li>
<li>控制报文 <strong>vs</strong> 数据报文<ul>
<li>带内、带外</li>
</ul>
</li>
<li>集中式 <strong>vs</strong> 分散式</li>
<li>无状态 <strong>vs</strong> 维护状态</li>
<li>可靠的 <strong>vs</strong> 不可靠的报文传输</li>
<li>在网络边缘处理复杂性</li>
</ul>
<p><font color='cornflowerblue'>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作</font></p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>运输层位于 应用层和网络层之间，是分层的网络体系结构的重要部分。 <strong>该层为 运行在不同主机上的应用进程提供直接的 通信服务起着至关重要的作用</strong>。</p>
<blockquote>
<p>“<strong>关注运输是什么，他如何工作，为什么这么做</strong>”</p>
</blockquote>
<p>目标：</p>
<ul>
<li>理解传输层的工作原理</li>
<li>多路复用&#x2F;解复用</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>学习 Internet 的传输层协议<ul>
<li>UDP ：无连接传输</li>
<li>TCP ：面向连接的 可靠性传输</li>
<li>TCP 的拥塞控制</li>
</ul>
</li>
</ul>
<h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>功能。</p>
<h3 id="传输服务器和协议"><a href="#传输服务器和协议" class="headerlink" title="传输服务器和协议"></a>传输服务器和协议</h3><ul>
<li><p>为运行在不同主机上的应用进程提供<font color='red'><strong>逻辑通信</strong></font></p>
</li>
<li><p>传输协议运行在端系统（而不是在路由器中实现的）</p>
<ul>
<li><p>发送方：将应用层的报文分成<font color='red'><strong>报文段</strong></font>，然后传递给网络层</p>
<p>实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段，然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）向目的地发送。</p>
</li>
<li><p>接收方：将报文段重组成报文，然后传递给应用层</p>
</li>
</ul>
</li>
<li><p>有多个传输层协议可供应用选择</p>
<ul>
<li>Internet：TCP和UDP</li>
</ul>
</li>
</ul>
<p>网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将改报文段向上交给运输层。运输层在处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs 网络层"></a>传输层 vs 网络层</h3><p>前面讲过，在协议栈中，运输层刚好位于网络层之上。网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<ul>
<li><strong>网络层服务</strong>：主机之间的逻辑通信</li>
<li><strong>传输层服务：</strong>进程间的逻辑通信<ul>
<li>依赖于网络层的服务<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604153158247.png" alt="image-20230604153158247" style="zoom:67%;" />

<blockquote>
<p>有些服务是可以加强的：不可靠  —&gt; 可靠：安全，但有些服务是不可以被加强的：带宽，延迟</p>
</blockquote>
<p>运输层协议只工作在端系统中，在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。中间路由器既不处理也不识别运输层加在应用层报文的任何信息。</p>
<p>运输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证。</p>
<p>然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如，即使底层网络协议是不可靠的，也就是说网络层协议会使分组丢失、篡改、冗余，运输协议也能为应用程序提供可靠的数据传输服务。另一个例子是,即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p>
<h3 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h3><p>在对UDP和TCP进行简要介绍之前，简单介绍一下因特网的网络层。因特网网络层协议有一个名字叫IP,即网际协议。IP为主机之间提供了逻辑通信。IP的服务模型是<strong>尽力而为交付</strong>服务（best-effort delivery service)。这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它<strong>并不做任何确保</strong>。特别是，它<strong>不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性</strong>。由于这些原因，<strong>IP被称为不可靠服务</strong>（unreliable service)。在此还要指出的是，每台主机至少有一个网络层地址，即所谓的IP地址。在这一章中，<strong>只需要记住每台主机都有一个 IP 地址</strong> 即可。</p>
<ul>
<li>可靠的、保序的传输：<strong>TCP</strong>（<font color='red'><strong>传输控制协议</strong></font>）<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序的传输：<strong>UDP</strong>（<font color='red'><strong>用户数据报协议</strong></font>）<ul>
<li>多路复用、解复用</li>
<li>没有尽力而为的IP服务添加更多的其他额外服务</li>
</ul>
</li>
<li>都不提供的服务：<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<p>在对 IP 有了初步的了解之后。总结一下 TCP 和 UDP 所提供的 服务模型。 UDP 和 TCP 最基本的责任是 <strong>将两个端系统间 IP 的交付服务扩展到运行在端系统上的两个进程之间的交互服务</strong>。将主机间交付扩展到进程之间的交付被称为 <font color='red'><strong>运输层的多路复用 与 多路分解</strong></font></p>
<h2 id="多路复用与解复用"><a href="#多路复用与解复用" class="headerlink" title="多路复用与解复用"></a>多路复用与解复用</h2> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230507115247237.png" alt="image-20230507115247237" style="zoom:67%;" />

<p><strong>运输层的多路复用与多路分解：</strong></p>
<p>将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。</p>
<h3 id="多路解复用工作原理"><a href="#多路解复用工作原理" class="headerlink" title="多路解复用工作原理"></a>多路解复用工作原理</h3><ul>
<li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程。</li>
<li>主机收到IP数据报<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据报承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号（特定应用有著名的端口号）</li>
</ul>
</li>
<li>主机联合使用<font color='red'><strong>IP地址</strong></font>和<font color='red'><strong>端口号</strong></font>将报文段发送给合适的套接字</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604155737828.png" alt="image-20230604155737828" style="zoom: 67%;" />

<p>现在应该清楚运输层是怎样能够实现分解服务的了：在主机上的每个套接字能够分一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP大体上是这样做的。然而，也将如我们所见，TCP中的多路复用与多路分解更为复杂。</p>
<h3 id="无连接（UDP）多路解复用"><a href="#无连接（UDP）多路解复用" class="headerlink" title="无连接（UDP）多路解复用"></a>无连接（UDP）多路解复用</h3><ul>
<li><p>创建套接字：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230507132635212.png" alt="image-20230507132635212" style="zoom:67%;" /></li>
</ul>
<p>serverSocket 和 sad 指定的端口号捆绑</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230507132722858.png" alt="image-20230507132722858" style="zoom:67%;" />

<p>没有 bind，clientSocket 和 os 为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）</p>
<ul>
<li><p>在接收端，UDP套接字用二元组标识（<font color='red'>目标IP地址、目标端口号</font>）</p>
</li>
<li><p>当主机收到UDP报文段：</p>
<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li><p>如果两个不同源IP地址&#x2F;源端口号的数据报，但是<font color='red'>有相同的目标IP地址和端口号</font>，则被定位到相同的socket套接字</p>
</li>
</ul>
<p><strong>例子</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604160037905.png" alt="image-20230604160037905" style="zoom:67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604160101330.png" alt="image-20230604160101330" style="zoom:67%;" /> 

<p>假定在主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据块给位于主机B中的另一个进程，该进程具有UDP端口46428.主机A中的运输层创建一个运输层报文段，其中包括 <strong>应用程序数据、源端口号（19157）、目的端口号（46428）和两个其他值。</strong>然后，运输层将得到的报文段传递到网络层。网络层将该报文段封装到一个IP数据报中，并尽力而为地将报文段交付给接收主机。如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号（46428）并将该报文段交付给端口号46428所标识的套接字。</p>
<h3 id="面向连接（TCP）的多路复用"><a href="#面向连接（TCP）的多路复用" class="headerlink" title="面向连接（TCP）的多路复用"></a>面向连接（TCP）的多路复用</h3><p>当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字。</p>
<p>特别与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。</p>
<p><strong>面向连接的解复用：例子</strong> </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604160951801.png" alt="image-20230604160951801" style="zoom:67%;" /> 

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604161015875.png" alt="image-20230604161015875" style="zoom:67%;" />

<ul>
<li>TCP套接字：四元组本地标识：<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
<li><font color='red'><strong>解复用：</strong></font>接收主机用这四个值来将数据报定位到合适的套接字 </li>
<li>服务器能够在一个TCP端口上同时支持多个TCP套接字：<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源port(端口号)），当一个TCP报文到达主机时，所有4个字段（源IP地址，源端口，目的IP地址，目的端口）被用来将报文段定向（分解）到响应的套接字。</li>
</ul>
</li>
<li>Web服务器对每个连接客户端有不同的套接字 <ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604161240554.png" alt="image-20230604161240554" style="zoom:67%;" />

<p>服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段（源IP地址，源端口，目的IP地址，目的端口）被用来将报文段定向（分解）到相应的套接字。</p>
<h3 id="面向连接的多路复用：多线程Web-Server"><a href="#面向连接的多路复用：多线程Web-Server" class="headerlink" title="面向连接的多路复用：多线程Web Server"></a>面向连接的多路复用：多线程Web Server</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230507134029591.png" alt="image-20230507134029591" style="zoom:67%;" />

<ul>
<li>一个进程下面可能有多个线程：由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据 4 元组决定将报文段内容 定向 到同一个进程下的不同线程</li>
<li>解复用到不同线程</li>
</ul>
<p>事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。对于这样一台服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程。</p>
<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>由 [RFC768] 定义的 UDP 只是做了<strong>运输协议能够做的最少工作</strong>。除了<strong>复用&#x2F;分解功能及少量的差错检测外</strong>，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人员选择UDP而不是TCP,则该应用程序差不多就是<strong>直接与IP打交道</strong>。UDP从应用进程得到数据，附加上用于多路复用&#x2F;分解服务的源和目的端口号字段，以及两个其他的小字段然后将形成的报文段交给网络层。<strong>网络层将该运输层报文段封装到一个IP数据报中</strong>，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，<u>在发送报文段之前，发送方和接收方的运输层实体之间没有握手</u>。正因为如此，<strong>UDP被称为是无连接的。</strong></p>
<h4 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h4><ul>
<li>“no frills”，”bare bones” Internet传输协议</li>
<li>“尽力而为” 的服务，报文段可能<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序</li>
</ul>
</li>
<li><font color='red'><strong>无连接：</strong></font><ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li>UDP被用于：<ul>
<li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>在UDP上可行可靠传输：<ul>
<li>在应用层增加可靠性 </li>
<li>应用特定的差错恢复</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230507135051078.png" alt="image-20230507135051078" style="zoom:67%;" />

<p>应用层数据占用UDP报文段的数据字段。UDP首部只有4个字段，每个字段由两个字节组成。</p>
<p>因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度。接收方使用检验和来检查在该报文段中是否出现了差错。实际上，计算检验和时，除了UDP报文段以外还包括了IP首部的一些字段。</p>
<p><font color='red'><strong>为什么要有UDP？</strong></font></p>
<ul>
<li><p>不建立连接（会增加延时） </p>
</li>
<li><p>简单：在发送端和接收端没有连接状态 </p>
</li>
<li><p>报文段的头部很小（开销小）</p>
</li>
<li><p>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段 </p>
<ul>
<li>应用 -&gt; 传输的速率 &#x3D; 主机 -&gt; 网络的速率</li>
</ul>
</li>
</ul>
<h4 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h4><p><font color='red'><strong>目标：</strong></font>检测在被传输报文段中的差错（如比特反转）</p>
<p>UDP检验和提供了差错检测功能。这就是说，检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。</p>
<p><font color='red'><strong>发送方：</strong></font></p>
<ul>
<li>将报文段的内容视为16比特的整数 </li>
<li>校验和：报文段的加法和（1的补运算）</li>
<li>发送方将校验和放在UDP的校验和字段</li>
</ul>
<p><font color='red'><strong>接收方：</strong></font></p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和字段的内容是否相等：<ul>
<li>不相等 —&gt; 检测到差错</li>
<li>相等 —&gt; 没有检测到差错，但也许还是有差错，残存错误</li>
</ul>
</li>
</ul>
<p>你可能想知道为什么UDP首先提供了检验和，就像许多链路层协议（包括流行的以太网协议）也提供了差错检测那样。其原因是不能保证源和目的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的 <strong>端到端原则</strong> （end-end principle)的例子[Saltzer1984],该原则表述为因为某种功能（在此时为差错检测）必须基于端到端实现：“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。”</p>
<h4 id="Internet校验和的例子"><a href="#Internet校验和的例子" class="headerlink" title="Internet校验和的例子"></a>Internet校验和的例子</h4><ul>
<li>注意：当数字相加时，在最高位的进位要回卷，在加到结果上</li>
</ul>
<p>例子：两个16比特的整数相加 </p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604162752056.png" alt="image-20230604162752056" style="zoom:50%;" />

<ul>
<li>目标端：校验范围 + 校验和 &#x3D; 1111111111111111  通过校验 <ul>
<li>否则没有通过校验</li>
</ul>
</li>
<li>注：求和时，必须将进位回卷到结果上</li>
</ul>
<p>因为 假定 IP 是可以 运行 在 任何第二层协议之上的，运输层 提供 差错检测作为一种保险措施时非常有用的。虽然 UDP 提供 差错检测，但他对 差错恢复无能为力。UDP 的某种 实现 <strong>只是丢弃了 受损的报文段</strong>；其他 实现则是将受损的 报文段交给应用程序并且 <strong>给出警告</strong></p>
<blockquote>
<p>UDP是一种无连接的传输协议，它在计算机网络中被广泛使用。</p>
<p>在UDP中，数据被分成小的数据包并通过网络进行传输。每个数据包包含源和目标端口号，以及数据本身。与TCP不同，UDP不需要在发送数据之前建立连接。因此，UDP的传输速度比TCP更快，但可靠性较差。</p>
<p>UDP的优势在于它能够快速地传输数据，而且需要的网络带宽较少。因此，它通常用于实时应用程序，例如音频和视频流。此外，UDP还可以用于广播和多播应用程序，使得多个接收方可以同时接收数据。</p>
<p>但是，UDP的不可靠性也是它的缺点之一。因为UDP不提供数据包重传和数据包排序等功能，因此在传输过程中可能会丢失一些数据包或将它们发送到错误的目的地。因此，在使用UDP时，我们需要考虑如何处理这些问题。</p>
<p>总之，UDP是一种快速、简单的无连接传输协议，可用于实时应用程序和广播多播应用程序。但是，由于它的不可靠性，我们需要考虑如何处理数据包丢失和乱序等问题。</p>
</blockquote>
<h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><p>可靠数据传输（reliable data transfer protocol）</p>
<h3 id="可靠数据传输（rdt）的原理"><a href="#可靠数据传输（rdt）的原理" class="headerlink" title="可靠数据传输（rdt）的原理"></a>可靠数据传输（rdt）的原理</h3><ul>
<li>rdt在应用层、传输层和数据链路层都很重要</li>
<li>是网络 Top 10 问题之一</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604213219665.png" alt="image-20230604213219665" style="zoom:67%;" />

<ul>
<li>信道的不可靠特点决定了可靠数据传输协议（rdt）的复杂性</li>
</ul>
<p>为上层实体提供的服务抽象是：<strong>数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付</strong>。实现这种服务抽象是<strong>可靠数据传输协议</strong>的责任。</p>
<h3 id="可靠数据传输：问题描述"><a href="#可靠数据传输：问题描述" class="headerlink" title="可靠数据传输：问题描述"></a>可靠数据传输：问题描述</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604213442140.png" alt="image-20230604213442140" style="zoom:67%;" />

<p><font color='red'><strong>我们将：</strong></font></p>
<ul>
<li>渐增式地开发可靠数据传输协议（rdt）的发送方和接收方</li>
<li>只考虑单向数据传输<ul>
<li>但控制信息是双向流动的！</li>
</ul>
</li>
<li>双向的数据传输问题实际上是 2 个单向数据传输问题的综合</li>
<li>使用<strong>有限状态机（FSM）</strong>来描述发送方和接收方</li>
</ul>
<p><font color='red'><strong>状态：</strong></font>在该状态时，下一个状态只由下一个事件唯一确定</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604213720052.png" alt="image-20230604213720052" style="zoom:50%;" />

<blockquote>
<p>FSM，全称为有限状态机，是一种表示有限状态和转移动作的数学模型。在计算机科学中，FSM通常用于描述计算机程序的行为，以及硬件系统的设计。</p>
<p>在FSM中，系统的行为被描述为一组状态，以及状态之间的转移动作。系统可以根据输入或事件，从一个状态转移到另一个状态。这种状态转移可以按照预定义的规则进行，或者根据某些条件进行。</p>
<p>FSM的优势在于它可以帮助我们更好地理解系统的行为，并帮助我们设计和开发计算机程序或硬件系统。FSM可以帮助我们定义系统的状态和转移动作，以及相应的输入和输出。这样可以更好地管理程序的复杂性，并确保系统的正确性和可靠性。</p>
<p>在计算机科学中，FSM被广泛应用于各种领域，例如编译器设计、协议分析、硬件系统设计和计算机游戏设计等。在编译器设计中，FSM可以帮助我们分析程序的语法结构，并生成相应的编译器代码。在协议分析中，FSM可以帮助我们识别和分析网络协议中的状态和转移动作。在硬件系统设计中，FSM可以帮助我们设计和实现自动控制系统。在计算机游戏设计中，FSM可以帮助我们设计和实现游戏中的角色行为和故事情节等。</p>
<p>总之，FSM是一种表示有限状态和转移动作的数学模型，通常用于描述计算机程序的行为和硬件系统的设计。FSM的优势在于它可以帮助我们更好地理解系统的行为，并帮助我们设计和开发计算机程序或硬件系统。</p>
</blockquote>
<h3 id="rdt1-0-：在可靠信道上的可靠数据传输"><a href="#rdt1-0-：在可靠信道上的可靠数据传输" class="headerlink" title="rdt1.0  ：在可靠信道上的可靠数据传输"></a>rdt1.0  ：在可靠信道上的可靠数据传输</h3><ul>
<li>下层的信道是完全可靠的<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的 <strong>FSM</strong><ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604214341115.png" alt="image-20230604214341115" style="zoom:67%;" />

<blockquote>
<p>rdt1.0是最简单的可靠数据传输协议，它只考虑了无差错情况下的数据传输。</p>
<p>在rdt1.0中，当发送方要发送数据时，它会直接将数据发送到接收方。接收方收到数据后，会发送一个确认消息给发送方，表示已经接收到了数据。如果发送方没有收到确认消息，则假定数据包已经丢失，并重新发送该数据包。</p>
<p>这种方案比较简单，但是只能够处理无差错情况下的数据传输，无法处理数据包损坏或丢失的情况。因此，在实际应用中，我们需要更加复杂的协议来确保可靠的数据传输。</p>
<p>总之，rdt1.0是最简单的可靠数据传输协议，它只能处理无差错情况下的数据传输。在实际应用中，我们需要更加复杂的协议来确保可靠的数据传输。</p>
</blockquote>
<h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><h4 id="rdt2-0-具有比特差错的信道"><a href="#rdt2-0-具有比特差错的信道" class="headerlink" title="rdt2.0: 具有比特差错的信道"></a>rdt2.0: 具有比特差错的信道</h4><ul>
<li>下层信道可能会出错：将分组中的比特翻转<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li>问题：怎样从差错中恢复：<ul>
<li><font color='red'>确认（ACK）：</font>接收方显示地告诉发送方分组已被正确接收</li>
<li><font color='red'>否定确认（NAK）：</font>接收方显示地告诉发送方分组发生了差错<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li><strong>rdt2.0</strong> 中的新机制：采用差错控制编码进行差错检测<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK、NAK）：接收方 -&gt; 发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
</ul>
<p>这种口述报文协议使用了<strong>肯定确认</strong>与<strong>否定确认</strong>。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。基于这样重传机制的可靠数据传输协议称为 <strong>自动重传请求</strong>（<font color='red'><strong>ARQ</strong></font>（Automatic Repeat reQuest））协议。</p>
<p>ARQ协议需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>差错检测</li>
<li>接收方反馈</li>
<li>重传</li>
</ul>
<h4 id="FSM描述"><a href="#FSM描述" class="headerlink" title="FSM描述"></a>FSM描述</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604225022993.png" alt="image-20230604225022993" style="zoom:67%;" />

<h4 id="没有差错时的操作"><a href="#没有差错时的操作" class="headerlink" title="没有差错时的操作"></a>没有差错时的操作</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604225058992.png" alt="image-20230604225058992" style="zoom:67%;" />

<h4 id="有差错时"><a href="#有差错时" class="headerlink" title="有差错时"></a>有差错时</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604225136921.png" alt="image-20230604225136921" style="zoom:67%;" />

<p>当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据；这就是说，rdt_send() 时间不可能出现；仅当接收到 ACK 并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0这样的协议被称为 <strong>停等</strong>（stop-and-wait）协议。</p>
<h3 id="rdt2-1-：处理出错的ACK-x2F-NAK"><a href="#rdt2-1-：处理出错的ACK-x2F-NAK" class="headerlink" title="rdt2.1 ：处理出错的ACK&#x2F;NAK"></a>rdt2.1 ：处理出错的ACK&#x2F;NAK</h3><h4 id="rdt2-0-的致命缺陷！-gt-rdt-2-1"><a href="#rdt2-0-的致命缺陷！-gt-rdt-2-1" class="headerlink" title="rdt2.0 的致命缺陷！ -&gt; rdt 2.1"></a>rdt2.0 的致命缺陷！ -&gt; rdt 2.1</h4><p><font color='red'><strong>如果ACK&#x2F;NAK出错？</strong></font></p>
<ul>
<li><p>发送方不知道接收方发生了什么事情！</p>
</li>
<li><p>发送方如何做？</p>
<ul>
<li>重传？可能重复</li>
<li>不重传？可能死锁（或出错）</li>
</ul>
</li>
<li><p>需要引入新的机制</p>
<ul>
<li>序号</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>处理重复：</strong></font></p>
<ul>
<li><p>发送方在每个分组中加入<font color='cornflowerblue'>序号</font></p>
</li>
<li><p>如果ACK&#x2F;NAK出错，发送方<font color='red'><strong>重传</strong></font>当前分组</p>
</li>
<li><p>接收方丢弃（不发给上层）重复分组</p>
</li>
</ul>
<blockquote>
<p><strong>停等协议</strong></p>
<p>发送方发送一个分组，然后等待接收方的应答</p>
</blockquote>
<h4 id="rdt2-1-发送方处理出错的ACK-x2F-NAK"><a href="#rdt2-1-发送方处理出错的ACK-x2F-NAK" class="headerlink" title="rdt2.1 : 发送方处理出错的ACK&#x2F;NAK"></a>rdt2.1 : 发送方处理出错的ACK&#x2F;NAK</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604225719165.png" alt="image-20230604225719165" style="zoom:67%;" />

<h4 id="rdt2-1-：接收方处理出错的ACK-x2F-NAK"><a href="#rdt2-1-：接收方处理出错的ACK-x2F-NAK" class="headerlink" title="rdt2.1 ：接收方处理出错的ACK&#x2F;NAK"></a>rdt2.1 ：接收方处理出错的ACK&#x2F;NAK</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604225928585.png" alt="image-20230604225928585"></p>
<h4 id="rdt2-1-：讨论"><a href="#rdt2-1-：讨论" class="headerlink" title="rdt2.1 ：讨论"></a>rdt2.1 ：讨论</h4><p><font color='red'><strong>发送方：</strong></font></p>
<ul>
<li>在分组中加入序列号，接收方只需要检查序列号即可确定收到的分组是否为重传。</li>
<li>两个序列号（0,1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测<strong>ACK&#x2F;NAK</strong>是否出错（需要<strong>EDC</strong>）</li>
<li>状态数变成了两倍<ul>
<li>必须记住当前分组的序列号为 0 还是 1</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>接收方：</strong></font></p>
<ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会知识希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了其 <strong>ACK&#x2F;NAK</strong><ul>
<li>没有安排确认的确认</li>
</ul>
</li>
</ul>
<h4 id="rdt2-1的运行"><a href="#rdt2-1的运行" class="headerlink" title="rdt2.1的运行"></a>rdt2.1的运行</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604230354561.png" alt="image-20230604230354561" style="zoom:67%;" />

<p>接收方不知道它最后发送的<strong>ACK&#x2F;NAK</strong>是否被正确地收到</p>
<ul>
<li>发送方不对收到的 <strong>ACK&#x2F;NAK</strong> 给确认，<font color='red'>没有所谓的确认的确认</font>；</li>
<li>接收方发送 ACK，如果后面接收方收到的是：<ul>
<li>老分组 p0？则 ACK 错误</li>
<li>下一个分组？P1，ACK正确</li>
</ul>
</li>
</ul>
<p>如果不发送<strong>NAK</strong>，只是对上次正确接收的分组发送一个 <strong>ACK</strong>，我们也能实现与NAK医用的效果。发送方接收到对同一个分组的两个ACK[即 接收<strong>冗余ACK</strong>]后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。</p>
<blockquote>
<p>rdt2.1是一种可靠数据传输协议，它可以处理数据包丢失和损坏的情况。</p>
<p>在rdt2.1中，发送方将每个数据包都增加一个序号，以便接收方可以检测丢失的数据包。发送方还会计算每个数据包的校验和并将其发送给接收方，以便接收方可以检测数据包是否损坏。当接收方收到一个数据包时，它会发送一个确认消息给发送方，表示已成功接收该数据包。如果接收方没有收到数据包，则发送NAK消息给发送方，请求重传该数据包。如果发送方收到NAK消息，则重新发送相应的数据包。</p>
<p>rdt2.1的优点在于它可以处理数据包丢失和损坏的情况，从而提高了数据传输的可靠性。但是，rdt2.1仍然存在一些缺点，例如它只能处理单个数据包丢失或损坏的情况，而无法处理多个数据包丢失或损坏的情况。此外，rdt2.1还可能存在死锁和无限重传的问题。</p>
<p>总之，rdt2.1是一种可靠数据传输协议，它可以处理数据包丢失和损坏的情况，从而提高了数据传输的可靠性。但是，它仍然存在一些缺点，需要在实际应用中进行改进和优化。</p>
</blockquote>
<h3 id="rdt2-2-：无NAK的协议"><a href="#rdt2-2-：无NAK的协议" class="headerlink" title="rdt2.2 ：无NAK的协议"></a>rdt2.2 ：无NAK的协议</h3><p>rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。</p>
<p>rdt2.1和rdt2.2之间的细微变化在于，接收方此时必须包括由一个ACK报文所确认的分组序号，发送方此时必须检查接收到的ACK报文中被确认的分组序号。</p>
<h4 id="rdt2-2-：无NAK的协议-1"><a href="#rdt2-2-：无NAK的协议-1" class="headerlink" title="rdt2.2 ：无NAK的协议"></a>rdt2.2 ：无NAK的协议</h4><ul>
<li>功能通rdt2.1，但只使用 <strong>ACK（ACK要编号）</strong> </li>
<li>接收方对<font color='red'>最后</font>正确接收的分组发ACK，以替代NAK<ul>
<li>接收方必须显示地包含被正确接收的<font color='red'>序号</font></li>
</ul>
</li>
<li>当收到重复的<strong>ACK</strong>（如：再次收到ACK0）时，发送方与收到<strong>NAK</strong>采取相同的动作：重传当前分组</li>
<li>为后面的一次发送多个数据单位做一个准备<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK、NAK；麻烦</li>
<li>使用对前一个数据单位的<strong>ACK</strong>，代替本数据单位的<strong>NAK</strong></li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<p><font color='cornflowerblue'><strong>NAK  free</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604231242529.png" alt="image-20230604231242529" style="zoom:50%;" />

<h4 id="rdt2-2的运行"><a href="#rdt2-2的运行" class="headerlink" title="rdt2.2的运行"></a>rdt2.2的运行</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604231307083.png" alt="image-20230604231307083" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604231417864.png" alt="image-20230604231417864" style="zoom: 67%;" />

<h4 id="rdt2-2-：发送方和接收方片断"><a href="#rdt2-2-：发送方和接收方片断" class="headerlink" title="rdt2.2 ：发送方和接收方片断"></a>rdt2.2 ：发送方和接收方片断</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604231517468.png" alt="image-20230604231517468" style="zoom:67%;" />

<blockquote>
<p>rdt2.0、rdt2.1和rdt2.2都是可靠数据传输协议，它们之间的区别和改进如下：</p>
<ol>
<li><p>rdt2.0：只能处理单个数据包丢失的情况，无法处理多个数据包丢失的情况。为了解决这个问题，rdt2.1和rdt2.2引入了选择重传和滑动窗口技术。</p>
</li>
<li><p>rdt2.1：引入了选择重传技术，可以处理多个数据包丢失的情况。选择重传技术允许发送方只重传丢失的数据包，而不是重传整个窗口中的所有数据包。这样可以减少重传的次数，提高传输效率。</p>
</li>
<li><p>rdt2.2：在rdt2.1的基础上引入了滑动窗口技术，可以进一步提高传输效率。滑动窗口技术允许发送方发送多个数据包，并等待接收方发送确认消息。如果接收方没有发送确认消息，则发送方会重传相应的数据包。滑动窗口技术可以在等待确认消息的同时发送多个数据包，从而提高传输效率。</p>
</li>
</ol>
<p>总之，rdt2.0、rdt2.1和rdt2.2都是可靠数据传输协议，它们之间的区别和改进在于处理多个数据包丢失的能力和传输效率的提高。rdt2.0只能处理单个数据包丢失的情况，rdt2.1引入了选择重传技术，可以处理多个数据包丢失的情况，而rdt2.2引入了滑动窗口技术，可以进一步提高传输效率。</p>
</blockquote>
<h3 id="rdt3-0-：具有比特差错和分组丢失的信道"><a href="#rdt3-0-：具有比特差错和分组丢失的信道" class="headerlink" title="rdt3.0 ：具有比特差错和分组丢失的信道"></a>rdt3.0 ：具有比特差错和分组丢失的信道</h3><h4 id="rdt3-0：具有比特差错和分组丢失的信道"><a href="#rdt3-0：具有比特差错和分组丢失的信道" class="headerlink" title="rdt3.0：具有比特差错和分组丢失的信道"></a>rdt3.0：具有比特差错和分组丢失的信道</h4><p><font color='red'><strong>新的假设：</strong></font>下层信道可能会丢失分组（数据或ACK）</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况：<ul>
<li>检验和</li>
<li>序列号</li>
<li><strong>ACK</strong></li>
<li>重传</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>方法：</strong></font></p>
<p>发送方等待<strong>ACK</strong>一段<font color='red'>合理的时间</font></p>
<p><u>（链路层的timeout时间是确定的，传输层timeout时间是适应式的）</u></p>
<ul>
<li>发送端超时重传：如果到时没有收到<strong>ACK</strong> -&gt; 重传</li>
<li>问题：如果分组（或<strong>ACK</strong>）只是被延迟了：<ul>
<li>重传将会导致数据重复，但利用<font color='red'>序列号</font>已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
<h4 id="rdt3-0-发送方"><a href="#rdt3-0-发送方" class="headerlink" title="rdt3.0 发送方"></a>rdt3.0 发送方</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604232245876.png" alt="image-20230604232245876" style="zoom: 67%;" />

<h4 id="rdt3-0-的运行"><a href="#rdt3-0-的运行" class="headerlink" title="rdt3.0 的运行"></a>rdt3.0 的运行</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604232445939.png" alt="image-20230604232445939" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604232527787.png" alt="image-20230604232527787" style="zoom:67%;" />

<h4 id="rdt3-0的性能"><a href="#rdt3-0的性能" class="headerlink" title="rdt3.0的性能"></a>rdt3.0的性能</h4><ul>
<li>rdt3.0可以工作，但链路容量比较大的情况下，性能很差<ul>
<li>链路容量比较大，一次发一个<strong>PDU</strong>的不能够充分利用链路的传输能力</li>
</ul>
</li>
</ul>
<p><strong>例子：</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604232749889.png" alt="image-20230604232749889" style="zoom: 67%;" />

<h4 id="rdt3-0-：停-等操作"><a href="#rdt3-0-：停-等操作" class="headerlink" title="rdt3.0 ：停-等操作"></a>rdt3.0 ：停-等操作</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604232855659.png" alt="image-20230604232855659" style="zoom:67%;" />

<blockquote>
<p>rdt3.0是一种可靠数据传输协议，它可以处理丢失、损坏和重复的数据包。</p>
<p>在rdt3.0中，发送方将每个数据包都增加一个序号，以便接收方可以检测丢失和重复的数据包。发送方还会计算每个数据包的校验和并将其发送给接收方，以便接收方可以检测数据包是否损坏。当接收方收到一个数据包时，它会检查数据包的序号是否正确，如果正确，则发送确认消息给发送方。如果接收方收到重复的数据包，则发送ACK消息表示已经接收过这个数据包。如果接收方收到的数据包不正确，则发送NAK消息给发送方，请求重传该数据包。如果发送方收到ACK消息，则认为该数据包已经成功发送，如果发送方收到NAK消息，则重新发送相应的数据包。</p>
<p>rdt3.0的优点在于它可以处理丢失、损坏和重复的数据包，从而提高了数据传输的可靠性。但是，rdt3.0仍然存在一些缺点，例如它无法处理数据包的乱序到达问题。此外，rdt3.0在处理重传问题时可能会导致网络拥塞和带宽浪费。</p>
<p>总之，rdt3.0是一种可靠数据传输协议，它可以处理丢失、损坏和重复的数据包，从而提高了数据传输的可靠性。但是，它仍然存在一些缺点，需要在实际应用中进行改进和优化。</p>
</blockquote>
<h3 id="流水线：提高链路利用率"><a href="#流水线：提高链路利用率" class="headerlink" title="流水线：提高链路利用率"></a>流水线：提高链路利用率</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604233023896.png" alt="image-20230604233023896" style="zoom:67%;" />

<h4 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h4><p><font color='red'><strong>流水线：</strong></font>允许发送方在<font color='red'>未得到对方确认</font>的情况下一次发送<strong>多个</strong>分组</p>
<ul>
<li>必须增加序号的范围：用多个 <strong>bit</strong> 表示分组的序号</li>
<li>在 发送方&#x2F;接收方 要有缓冲区<ul>
<li>发送方缓冲：未得到确认，可能需要重传</li>
<li>接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率：接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604233343930.png" alt="image-20230604233343930" style="zoom:67%;" />

<ul>
<li>两种通用的流水线协议：<font color='red'><strong>回退N步（GBN）</strong></font>(Go-Back-N)和 <font color='red'><strong>选择重传（SR）</strong></font>(Selective Repeat, SR)</li>
</ul>
<h3 id="通用：滑动窗口（slide-window）协议"><a href="#通用：滑动窗口（slide-window）协议" class="headerlink" title="通用：滑动窗口（slide window）协议"></a>通用：滑动窗口（slide window）协议</h3><ul>
<li>发送缓冲区<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有得到确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组<ul>
<li>停止等待协议 &#x3D; 1</li>
<li>流水线协议 &gt; 1，合理的值，不能很大，链路利用率不能超过 100%</li>
</ul>
</li>
<li>发送缓冲区中的分组<ul>
<li><font color='red'><strong>未发送的：</strong></font>落入发送缓冲区的分组，可以连续发送出去</li>
<li><font color='cornflowerblue'>已经发送出去的、等待对方确认的分组：</font>发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
</ul>
<h4 id="发送窗口滑动过程-相对表示方法"><a href="#发送窗口滑动过程-相对表示方法" class="headerlink" title="发送窗口滑动过程 - 相对表示方法"></a>发送窗口滑动过程 - 相对表示方法</h4><ul>
<li>采用相对移动方式表示，分组不动</li>
<li>可缓冲范围移动，代表一段可以发送的权利</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604234156387.png" alt="image-20230604234156387" style="zoom:67%;" />

<h4 id="滑动窗口（slide-window）协议"><a href="#滑动窗口（slide-window）协议" class="headerlink" title="滑动窗口（slide window）协议"></a>滑动窗口（slide window）协议</h4><ul>
<li>发送窗口：发送缓冲区内容的一个范围<ul>
<li>那些<font color='red'>已发送</font>但是<font color='red'>未经确认</font>分组的序号构成的空间</li>
</ul>
</li>
<li>发送窗口的最大值 <strong>&lt;&#x3D;</strong> 发送缓冲区的值</li>
<li>一开始：没有发送任何一个分组<ul>
<li>后沿 &#x3D; 前沿</li>
<li>之前为发送窗口的尺寸 &#x3D; 0</li>
</ul>
</li>
<li>每发送一个分组，前沿前移一个单位</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230604234455364.png" alt="image-20230604234455364" style="zoom: 67%;" />

<h4 id="发送窗口的移动-gt-前沿移动"><a href="#发送窗口的移动-gt-前沿移动" class="headerlink" title="发送窗口的移动 -&gt; 前沿移动"></a>发送窗口的移动 -&gt; 前沿移动</h4><ul>
<li>发送窗口前沿移动的极限：不能够超过发送缓冲区</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605084513283.png" alt="image-20230605084513283" style="zoom:67%;" />

<ul>
<li>发送窗口前沿移动的极限：不能够超过发送缓冲区</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605084609499.png" alt="image-20230605084609499" style="zoom: 67%;" />

<h4 id="发送窗口的移动-gt-后沿移动"><a href="#发送窗口的移动-gt-后沿移动" class="headerlink" title="发送窗口的移动 -&gt; 后沿移动"></a>发送窗口的移动 -&gt; 后沿移动</h4><ul>
<li>发送窗口后沿移动<ul>
<li>条件：收到老分组的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动的极限：不能够超过前沿</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605084752003.png" alt="image-20230605084752003" style="zoom:67%;" />

<ul>
<li>发送窗口后沿移动<ul>
<li>条件：收到老分组（后沿）的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动的极限：不能够超过前沿</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605085018917.png" alt="image-20230605085018917" style="zoom:67%;" />

<h4 id="滑动窗口协议-发送窗口"><a href="#滑动窗口协议-发送窗口" class="headerlink" title="滑动窗口协议-发送窗口"></a>滑动窗口协议-发送窗口</h4><ul>
<li>滑动窗口技术<ul>
<li>发送窗口（sending window）</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605085809308.png" alt="image-20230605085809308" style="zoom:67%;" />

<h4 id="滑动窗口协议-接收窗口"><a href="#滑动窗口协议-接收窗口" class="headerlink" title="滑动窗口协议-接收窗口"></a>滑动窗口协议-接收窗口</h4><ul>
<li><p>接收窗口（receiving window）&#x3D; 接收缓冲区</p>
<ul>
<li><p>接收窗口用于控制哪些分组可以接收：</p>
<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li><p>接收窗口尺寸 <strong>Wr&#x3D;1</strong> ，则只能顺序接收</p>
</li>
<li><p>接收窗口尺寸 <strong>Wr&gt;1</strong> ，则可以乱序接收</p>
<ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
<li><p>例子：<strong>Wr&#x3D;1</strong>，在0的位置；只有0号分组可以接收；</p>
<p>向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃；</p>
</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605090330128.png" alt="image-20230605090330128" style="zoom:67%;" />

<ul>
<li>接收窗口的滑动和发送确认<ul>
<li>滑动：<ul>
<li>低序号的分组到来，接收窗口移动；</li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</li>
</ul>
</li>
<li>发送确认：<ul>
<li>接收窗口尺寸 <strong>&#x3D;1</strong>，发送连续接收到的最大的分组确认（累计确认）</li>
<li>接收窗口尺寸 <strong>&gt;1</strong>，收到分组，发送那个分组的确认（非累积确认）</li>
</ul>
</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605090624712.png" alt="image-20230605090624712" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605090651233.png" alt="image-20230605090651233" style="zoom:67%;" />

<h3 id="窗口互动"><a href="#窗口互动" class="headerlink" title="窗口互动"></a>窗口互动</h3><h4 id="正常情况下的2个窗口互动"><a href="#正常情况下的2个窗口互动" class="headerlink" title="正常情况下的2个窗口互动"></a>正常情况下的2个窗口互动</h4><ul>
<li>发送窗口<ul>
<li>有新的分组落入发送缓冲区范围，发送 -&gt; 前沿滑动</li>
<li>来了老的低序号分组的确认 -&gt; 后沿向前滑动 -&gt; 新的分组可以落入发送缓冲区的范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到分组，落入到接收窗口范围内，接收</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
<li>发送端上面来了分组 -&gt; 发送窗口滑动 -&gt; 接收窗口滑动 -&gt; 发确认</li>
</ul>
<h4 id="异常情况下GBN的2窗口互动"><a href="#异常情况下GBN的2窗口互动" class="headerlink" title="异常情况下GBN的2窗口互动"></a>异常情况下GBN的2窗口互动</h4><ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去</li>
<li>来了老分组的重复确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，没有落入到接收窗口范围内，抛弃</li>
<li>（重复）发送老分组的确认，累计确认</li>
</ul>
</li>
</ul>
<h4 id="异常情况下SR的2窗口互动"><a href="#异常情况下SR的2窗口互动" class="headerlink" title="异常情况下SR的2窗口互动"></a>异常情况下SR的2窗口互动</h4><ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动</li>
<li>超时重发机制让发送端将超时的分组重新发送出去</li>
<li>来了乱序分组的确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，单独确认</li>
</ul>
</li>
</ul>
<h3 id="流水线协议：总结"><a href="#流水线协议：总结" class="headerlink" title="流水线协议：总结"></a>流水线协议：总结</h3><h4 id="GBN和SR"><a href="#GBN和SR" class="headerlink" title="GBN和SR"></a>GBN和SR</h4><p><font color='red'><strong>Go-back-N（GBN）：</strong></font>（回退N步）</p>
<p>数据必须<strong>按序交付</strong>，在GBN协议中，接收方丢弃所有失序分组。</p>
<p>在接收方，如果分组2丢失，即使3,4,5都成功确认也要被丢弃重传，这就是按序交付。</p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组</li>
<li>接收端只是发送累计型确认 <strong>cumulative ack</strong>，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。<ul>
<li>接收端如果发送 gap，不确认新到来的分组</li>
</ul>
</li>
<li>发送端拥有对赘肉的未确认分组的定时器<ul>
<li>只需设置<font color='red'><strong>一个定时器</strong></font></li>
<li>当定时器到时时，<font color='red'>重传所有未确认分组</font></li>
</ul>
</li>
</ul>
<p><font color='red'><strong>Selective Repeat（SR）：</strong></font></p>
<p>选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。</p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组</li>
<li>接收方对每个到来的分组单独确认 <strong>individual ack</strong> （非累计确认）</li>
<li>发送方为每个<font color='red'><strong>未确认的分组保持一个定时器</strong></font><ul>
<li>当超时定时器到时，只重发到时的未确认分组</li>
</ul>
</li>
</ul>
<p>如果接收方不确认该分组，则发送方窗口将永远不能向前滑动！这说明，对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果，对于SR而言，这就意味着发送方和接收方的窗口并不总是一致（缺乏同步会产生严重的后果）。</p>
<h4 id="GBN：扩展的FSM"><a href="#GBN：扩展的FSM" class="headerlink" title="GBN：扩展的FSM"></a>GBN：扩展的FSM</h4><p><strong>GBN：发送方扩展的FSM</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605093232765.png" alt="image-20230605093232765" style="zoom:67%;" />

<p><strong>GBN：接收方扩展的FSM</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605093412632.png" alt="image-20230605093412632" style="zoom: 67%;" />

<ul>
<li>只发送<strong>ACK：</strong>对顺序接收的最高序号的分组<ul>
<li>可能会产生重复的 ACK</li>
<li>只需记住 <strong>expectedseqnum</strong> ；接收窗口 &#x3D; 1，<strong>只一个变量就可表示接收窗口</strong></li>
</ul>
</li>
<li>对乱序的分组：<ul>
<li>丢弃（不缓存）-&gt; <font color='red'>在接收方不被缓存！</font></li>
<li>对顺序接收的最高序号的分组进行确认 - 累计确认</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605093717919.png" alt="image-20230605093717919" style="zoom:67%;" />

<blockquote>
<p>扩展FSM指的是扩展有限状态机（Finite State Machine），它是一种模型，用于描述系统的各种状态和状态之间的转移。</p>
<p>在扩展FSM中，我们可以添加新的状态和转移，以适应系统的需求。例如，我们可以添加新的状态来表示系统的故障或者异常状态，或者添加新的转移来处理系统的错误或者异常情况。</p>
<p>扩展FSM的优点在于它可以更好地描述系统的各种状态和状态之间的转移，从而提高系统的可靠性和稳定性。但是，扩展FSM也存在一些缺点，例如它可能会导致状态的数量增加，从而增加系统的复杂性和开销。</p>
<p>总之，扩展FSM是一种用于描述系统的各种状态和状态之间的转移的模型，它可以添加新的状态和转移来适应系统的需求，从而提高系统的可靠性和稳定性。但是，扩展FSM也需要在实际应用中仔细考虑其优缺点，并进行合理的设计和优化。</p>
</blockquote>
<p><strong>运行中的GBN</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605093758569.png" alt="image-20230605093758569" style="zoom:67%;" /> 

<h4 id="选择重传SR"><a href="#选择重传SR" class="headerlink" title="选择重传SR"></a>选择重传SR</h4><ul>
<li><p>接收方对每个正确接收的分组，分别发送 <strong>ACKn</strong>（非累积确认）</p>
<ul>
<li>接收窗口 <strong>&gt;1</strong><ul>
<li>可以缓存乱序的分组</li>
</ul>
</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li><p>发送方只对那些没有收到<strong>ACK</strong>的分组进行重发 - 选择性重发</p>
<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li><p>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p>
<p>如果收到ACK，倘若该分组序号在窗口内，则SR发送方将哪个被确认的分组标记为已接收，窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</p>
</li>
</ul>
<p><strong>发送方</strong></p>
<p><font color='red'><strong>从上层接收数据：</strong></font></p>
<ul>
<li>如果下一个可用于该分组的序号可在发送窗口中，则发送 <strong>timeout(n)</strong></li>
<li>重新发送分组 n，重新设定定时器</li>
</ul>
<p><font color='red'><strong>ACK(n)</strong></font> in [sendbase, sendbase+N]：</p>
<ul>
<li>将分组 n 标记为已接收</li>
<li>如 n 为最小未确认的分组序号，</li>
<li>将 base 移到下一个未确认序号</li>
</ul>
<p><strong>接收方：</strong></p>
<p><font color='red'><strong>分组n</strong></font>[rcvbase, rcvbase + N - 1]</p>
<ul>
<li>发送<strong>ACK(n)</strong></li>
<li>乱序：缓存</li>
<li>有序：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组</li>
</ul>
<p><font color='red'><strong>分组n</strong></font> [rcvbase-N，rcvbase-1]</p>
<ul>
<li><strong>ACK(n)</strong></li>
</ul>
<p><font color='red'><strong>其他：</strong></font></p>
<ul>
<li>忽略该分组</li>
</ul>
<p><strong>选择重传SR的运行</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605094952475.png" alt="image-20230605094952475" style="zoom: 67%;" />

<h3 id="GBN协议和SR协议的异同"><a href="#GBN协议和SR协议的异同" class="headerlink" title="GBN协议和SR协议的异同"></a>GBN协议和SR协议的异同</h3><h4 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h4><ul>
<li>发送窗口 <strong>&gt;1</strong></li>
<li>一次能够可发送多个未经确认的分组</li>
</ul>
<h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ul>
<li>GBN：接收窗口尺寸 <strong>&#x3D;1</strong><ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4；假如1未成功，234都发送出去了，<font color='red'>要返回1再发送：GB1</font></li>
</ul>
</li>
<li>SR：接收窗口尺寸 <strong>&gt;1</strong><ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送0，1,2,3,4；一旦1未成功，2,3，4 已发送，无需重发，<font color='red'>选择性发送1</font></li>
</ul>
</li>
</ul>
<h4 id="对比GBN和SR"><a href="#对比GBN和SR" class="headerlink" title="对比GBN和SR"></a>对比GBN和SR</h4><table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个缓存单元）</td>
<td>出错时，重传一个（代价小）</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步（代价大）</td>
<td>复杂，所需要的资源多（接收方多个缓存单元）</td>
</tr>
</tbody></table>
<ul>
<li>适用范围<ul>
<li>出错率低：比较适合<strong>GBN</strong>，出错非常罕见，没有必要用复杂的<strong>SR</strong>，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大，带宽大）：比较适合<strong>SR</strong>而不是<strong>GBN</strong>，一点出错代价太大。</li>
</ul>
</li>
</ul>
<h4 id="窗口的最大尺寸"><a href="#窗口的最大尺寸" class="headerlink" title="窗口的最大尺寸"></a>窗口的最大尺寸</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605095458724.png" alt="image-20230605095458724" style="zoom:67%;" />

<h3 id="可靠数据传输机制及其用途的总结"><a href="#可靠数据传输机制及其用途的总结" class="headerlink" title="可靠数据传输机制及其用途的总结"></a>可靠数据传输机制及其用途的总结</h3><table>
<thead>
<tr>
<th>机制</th>
<th>用途和说明</th>
</tr>
</thead>
<tbody><tr>
<td>检验和</td>
<td>用于检测在一个传输分组中的比特错误</td>
</tr>
<tr>
<td>定时器</td>
<td>用于超时&#x2F;重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失（过早超时），或当一个分组已被接收方收到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本</td>
</tr>
<tr>
<td>序号</td>
<td>用于为从发送方刘翔接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本</td>
</tr>
<tr>
<td>确认</td>
<td>接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以使逐个的或累积的，这取决于协议</td>
</tr>
<tr>
<td>否定确认</td>
<td>接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号</td>
</tr>
<tr>
<td>窗口、流水线</td>
<td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置</td>
</tr>
</tbody></table>
<h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><p>TCP被称为是面向连接的（connection-oriented),这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量（其中的许多状态变量将在本节和3.7节中讨论）。</p>
<p>TCP是<strong>全双工</strong>的。</p>
<h3 id="TCP：概述"><a href="#TCP：概述" class="headerlink" title="TCP：概述"></a>TCP：概述</h3><p>这种TCP“连接”不是一条像在电路交换网络中的端到端TDM或FDM电路。相反，<strong>该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中</strong>。</p>
<p>由于 TCP 协议只在 端系统中运行 ，而不在中间的 网络元素（路由器和链路层 ）中运行， <strong>所以 中间的网络元素 并不会 维持 TCP 连接</strong></p>
<blockquote>
<p>事实上，<strong>中间 路由器对 TCP 的连接视而不见，他们看到的 是 数据报，而不是连接</strong></p>
</blockquote>
<p>TCP 的 连接也总是 点对点的（point - to - point），即 <strong>在单个发送方和单个接收方之间的连接</strong></p>
<p>我们现在来看看TCP连接是怎样建立的。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接。<strong>发起连接的</strong>这个进程被称为<strong>客户进程</strong>，而另一个进程被称为<strong>服务器进程</strong>。</p>
<p>该客户应用进程首先要通知客户运输层，它想与服务器上的一个进程建立一条连接。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">clientsocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中 <code>serverName</code> 是服务器的名字，<code>serverPort</code> 标识了服务器上的进程。客户边开始与服务器上上的 TCP 建立一条 TCP 连接。</p>
<ol>
<li>客户首先发送一个特殊的TCP报文段</li>
<li>服务器用另一个特殊的TCP报文段来响应</li>
<li>客户再用第三个特殊报文段作为响应</li>
</ol>
<p>前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了3个报文段，所以这种连接建立过程常被称为 <strong>三次握手（three-way handshake）</strong></p>
<p>一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。</p>
<p>下面考虑一下从客户进程向服务器进程发送数据的情况。客户进程通过套接字（该进程之门）传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。如图3-28所示，TCP将这些数据引导到该连接的<strong>发送缓存（send buffer)<strong>里，发送缓存是发起三握手期间设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据，并将数据传递到网络层。有趣的是，在TCP规范[RFC793]中却没提及TCP应何时实际发送缓存里的数据，只是描述为 “</strong>TCP应该在它方便的时候以报文段的形式发送数据</strong>” 。TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度（Maximum Segment Size,MSS)<strong>。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的</strong>最大传输单元（Maximum Transmission Unit,MTU))<strong>来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上TCP&#x2F;IP首部长度（通常40字节）将适合单个链路层帧。以太网和PPP链路层协议都具有1500字节的MTU,<strong>因此MSS的典型值为1460字节</strong>。注意到</strong>MSS是指在报文段里应用层数据的最大（有效）长度，而不是指包括首部的TCP报文段的最大长度。</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230510234825220.png" alt="image-20230510234825220"></p>
<p>TCP为每块客户数据配上一个TCP首部，从而形成多个<strong>TCP报文段</strong>，这些报文段被下传给网络层，网络层将其封装在网络层 IP 数据报中。然后这些 IP 数据报被发送到网络中。当 TCP 在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP连接的接收缓存中。如上图所示，应用从此缓存中读取的数据流，该连接的每一段都有各自的发送缓存和接收缓存。</p>
<blockquote>
<p>TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连接分配任何缓存和变量。</p>
</blockquote>
<ul>
<li><font color='red'><strong>点对点：</strong></font><ul>
<li>一个发送方，一个接收方</li>
</ul>
</li>
<li><font color='red'><strong>可靠的、按顺序的字节流：</strong></font><ul>
<li>没有报文边界</li>
</ul>
</li>
<li><font color='red'><strong>管道化（流水线）：</strong></font><ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li><font color='red'><strong>发送和接收缓存</strong></font></li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605124059777.png" alt="image-20230605124059777" style="zoom:67%;" />

<ul>
<li><font color='red'><strong>全双工数据：</strong></font><ul>
<li>在同一连接中数据流双向流动</li>
<li><strong>MSS：</strong>最大报文段大小</li>
</ul>
</li>
<li><font color='red'><strong>面向连接：</strong></font><ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li>
</ul>
</li>
<li><font color='red'><strong>有流量控制：</strong></font><ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><h4 id="TCP报文段结构-1"><a href="#TCP报文段结构-1" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605124339140.png" alt="image-20230605124339140" style="zoom:67%;" />

<p>TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。MSS限制了报文段数据字段的最大长度。</p>
<p>首部包括<strong>源端口号</strong>和<strong>目的端口号</strong>，它被用于多路复用&#x2F;分解来自或送到上层应用的数据。</p>
<h4 id="TCP序号，确认号"><a href="#TCP序号，确认号" class="headerlink" title="TCP序号，确认号"></a>TCP序号，确认号</h4><p><font color='red'><strong>序号：</strong></font>（32比特）</p>
<ul>
<li>报文段首字节的在字节流的编号</li>
</ul>
<p><font color='red'><strong>确认号：</strong></font>（32比特）</p>
<ul>
<li>期望从另一方收到的下一个字节的序号</li>
<li>累积确认</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605124516595.png" alt="image-20230605124516595" style="zoom:67%;" />

<p>这两个字段是TCP可靠传输服务的关键部分。</p>
<p>TCP把数据看成一个无结构的、有序的字节流。我们从 TCP 对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。<strong>一个报文段的序号</strong>因此是该报文段首字节的字节流编号。</p>
<p>TCP是全双工的，因此主机 A 在向主机 B 到达的每个报文段中都有一个序号用于从 B 流向 A 的数据。<strong>主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号</strong> （假设主机A已经收到了来自主机B的编号 0 ~ 535的所有字节，同时假设它打算发送一个报文段给主机B，主机A等待主机B的数据流中子产品536即之后的所有字节，所以主机A就会在它发往主机B的报文段的确认号字段中填上536）。</p>
<p>当主机在一条 TCP 连接中收到失序报文段时该怎么办？TCP把这一问题留给了实现TCP的编程人员去处理，他们有两种基本的选择</p>
<ol>
<li>接收方立即丢弃失序报文段</li>
<li>接收方保留失序的字节，并等待缺少的字节以填补该间隔。（这种选择对网络带宽而言更为有效，是实践中采用的方法）</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605124543767.png" alt="image-20230605124543767" style="zoom:67%;" /> 

<p>第一个报文段是由客户发往服务器，<strong>Seq&#x3D;42</strong> 表示客户端给服务器字节从42开始（包括42），而且客户端希望服务器发送确认字段从79开始，data表示客户端传输给服务器的数据部分</p>
<p>第二个报文段是由服务器发往客户端的，它有两个目的：</p>
<ol>
<li>第一个目的：它是为该服务器所收到数据提供一个确认。通过在确认号字段中填入 43，服务器告诉客户它已经成功地收到字节42及以前的所有字节，现在正等待着字节43的出现。</li>
<li>第二个目的：回显字符 ‘C’ 。第二个报文段的序号为 79，它是该 TCP 连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节的数据。</li>
</ol>
<p>对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中；这种确认被称为是被<strong>捎带</strong>在服务器到客户的数据报文中的。</p>
<h4 id="TCP往返延时（RTT）和超时"><a href="#TCP往返延时（RTT）和超时" class="headerlink" title="TCP往返延时（RTT）和超时"></a>TCP往返延时（RTT）和超时</h4><p>TCP 如 rdt 一样，它采用 超时&#x2F; 重传 机制来处理报文段的丢失问题。<strong>但是 超时 间隔长度的设置 是一个明显的问题</strong>。显然，超时时间间隔 必须大于 该连接 的RTT，即从一个报文段发出到它被确认的时间，否则 会造成 不必要的 重传</p>
<p><font color='red'><strong>Q：怎样设置TCP超时？</strong></font></p>
<ul>
<li>比 RTT 要长<ul>
<li>但 RTT 是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段的丢失反应太慢</li>
</ul>
<p><strong>估计往返时间</strong></p>
<p>估计之间往返时间的。这是通过如下方法完成的。报文段的样本RTT(表示为SampleRTT)就是<strong>从某报文段被发出（即交给IP)到对该报文段的确认被收到之间的时间量</strong>。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而<strong>不是为每个</strong>发送的报文段测量一个SampleRTT。这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计Samp-leRTT, 从而产生一个接近每个RTT的新SampleRTT值。另外，<strong>TCP决不为已被重传的报文段计算SampleRTT</strong>; 它仅为传输一次的报文段测量SampleRTT[Kan1987] </p>
<p>显然，由于<strong>路由器的拥塞和端系统负载的变化</strong>，这些报文段的 SampleRTT 值会随之波动。由于这种波动，任何给定的SampleRTT值也许<strong>都是非典型</strong>的。因此，为了估计一个典型的RTT,自然要采取某种对SampleRTT<strong>取平均</strong>的办法。TCP维持一个SampleRTT均值(称为EstimatedRTT)。一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT : </p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605144150367.png" alt="image-20230605144150367" style="zoom: 67%;" />

<ul>
<li>指数加权移动平均</li>
<li>过去样本的影响呈指数衰减</li>
<li>推荐值：α &#x3D; 0.125</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605144300542.png" alt="image-20230605144300542" style="zoom:67%;" />

<p><strong>Q</strong>：怎样估计 RTT</p>
<ul>
<li><strong>SampleRTT</strong>：测量 报文段发出到收到确认的 时间<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li>SampleRTT 会变化，因此估计的 RTT 应该比较平滑<ul>
<li>对 几个最近的测量值求平均，而不是仅用当前的 <strong>SampleRTT</strong></li>
</ul>
</li>
</ul>
<p><strong>设置和管理重传超时间隔</strong></p>
<p>很明显，超时间隔应该大于等于<code>EstimatedRTT</code> 否则，将造成不必要的重传。但是超时间隔也不应该比 <code>EstimatedRTT </code>大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为 <code>EstimatedRTT </code>加上一定余量。当 <code>SampleRTT </code>值波动较大时，这个余量应该大些；当波动较小时，这个余量应该小些。因此：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511124354617.png" alt="image-20230511124354617" style="zoom: 80%;" />

<p>推荐的 <code>TimeoutInterval </code>为 1 s, 同时当出现超时时， <code>TimeoutInterval </code>值将加倍，以免即将被确认的后继报文段过早出现超时。然而，<strong>只要收到报文段并更新 <code>EstimatedRTT</code>, 就使用上述公式再次计算 <code>TimeoutInterval </code></strong></p>
<p><font color='red'><strong>设置超时：</strong></font></p>
<ul>
<li><strong>EstimtedRTT</strong> + 安全边界时间<ul>
<li><strong>EstimatedRTT变化</strong>大（方差大） -&gt; 较大的安全边界时间</li>
</ul>
</li>
<li>SampleRTT 会偏离 <strong>EstimateRTT</strong>多远：</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511124858456.png" alt="image-20230511124858456" style="zoom: 50%;" />

<ul>
<li>超时时间设置</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511124925817.png" alt="image-20230511124925817" style="zoom:50%;" />

<h3 id="TCP：可靠数据传输"><a href="#TCP：可靠数据传输" class="headerlink" title="TCP：可靠数据传输"></a>TCP：可靠数据传输</h3><p>因特网的网络层服务（IP服务）是不可靠的。</p>
<blockquote>
<p>IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性</p>
<p>对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地。数据报也可能是乱序到达，而且数据报中的比特可能损坏</p>
</blockquote>
<p>由于<strong>运输层报文段是被IP数据报携带着在网络中传输的</strong>，所以运输层的报文段也会遇到这些问题。</p>
<p>TCP在IP不可靠的<strong>尽力而为服务</strong>（可以认为是<strong>完全没服务</strong>）之上创建了一种可靠数据传输服务（reliable datatransfer service)。</p>
<blockquote>
<p>TCP的可靠数据传输服务确保<strong>一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非穴余和按序的数据流</strong>；即该字节流与连接的另一方端系统发送出的字节流是完全相同。TCP提供可靠数据传输的方法涉及在 rdt 中所学的许多原理。</p>
</blockquote>
<h4 id="TCP：可靠数据传输-1"><a href="#TCP：可靠数据传输-1" class="headerlink" title="TCP：可靠数据传输"></a>TCP：可靠数据传输</h4><ul>
<li><p>TCP在IP不可靠服务的基础上建立了rdt</p>
<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>是否可以接收乱序的，没有规范</li>
</ul>
</li>
<li><p>通过以下时间触发重传</p>
<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>重复的确认<ul>
<li>例子：收到了 ACK50，之后又收到 3 个 ACK50</li>
</ul>
</li>
</ul>
</li>
<li><p>首先考虑简化的TCP发送方：</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h4 id="TCP-发送方（简化版）"><a href="#TCP-发送方（简化版）" class="headerlink" title="TCP 发送方（简化版）"></a>TCP 发送方（简化版）</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605145503526.png" alt="image-20230605145503526" style="zoom:67%;" />

<h4 id="TCP发送方事件："><a href="#TCP发送方事件：" class="headerlink" title="TCP发送方事件："></a>TCP发送方事件：</h4><p><font color='red'><strong>从应用层接收数据：</strong></font></p>
<ul>
<li>用<strong>nextseq</strong>创建报文段</li>
<li>序号<strong>nextseq</strong>为报文段首字节的字节流编号，交给IP</li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔：<code>TimeOutInterval</code></li>
</ul>
</li>
</ul>
<p><font color='red'><strong>超时：</strong></font></p>
<p>TCP通过重传引起的报文段来响应超时事件。然后TCP重启定时器。</p>
<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时器</li>
</ul>
<p><font color='red'><strong>收到确认：</strong></font></p>
<ul>
<li>如果是对尚未确认的报文段确认<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605145929373.png" alt="image-20230605145929373" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511132717792.png" alt="image-20230511132717792" style="zoom:67%;" />

<h4 id="TCP：重传"><a href="#TCP：重传" class="headerlink" title="TCP：重传"></a>TCP：重传</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511132749009.png" alt="image-20230511132749009" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511132807187.png" alt="image-20230511132807187" style="zoom:67%;" />

<h4 id="TCP快速重传"><a href="#TCP快速重传" class="headerlink" title="TCP快速重传"></a>TCP快速重传</h4><ul>
<li>超时周期往往太长：<ul>
<li>在重传丢失报文之前的延时太长，增加了端到端的时延。</li>
</ul>
</li>
<li>通过<font color='red'>重复</font>的<strong>ACK</strong>来检测报文段丢失<ul>
<li>发送方通常连续发送大量报文段</li>
<li>如果报文段丢失，通常会引起多个重复的<strong>ACK</strong></li>
</ul>
</li>
<li>如果发送方收到同一数据的 3 个冗余 ACK，重传最小序号的段：<ul>
<li><font color='red'><strong>快速重传：</strong></font>在定时器过时之前重发报文段</li>
<li>它假设跟在被确认的数据后面的数据丢失了<ul>
<li>第一个ACK是正常的；</li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段；</li>
<li>收到 3, 4 个该段的 ACK，表示接收方收到该段之后的 2 个，3个乱序段，可能性非常大，段丢失了。</li>
</ul>
</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605151159842.png" alt="image-20230605151159842" style="zoom:67%;" />

<p><strong>快速重传</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511133728302.png" alt="image-20230511133728302" style="zoom:67%;" />

<p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。冗余ACK(duplicate ACK) 就是<strong>再次确认某个报文段的ACK</strong>,而发送方<strong>先前已经收到</strong>对该报文段的确认。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511133016647.png" alt="image-20230511133016647"></p>
<p>因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的 冗余ACK（因为服务器也需要客户端确认收到这个ACK，客户端如果没有发送或丢失发给服务器的ACK，则服务器会一直给客户端发之前的ACK，直到得到客户端的确认）。如果TCP发送方接收到对相同数据的 3 个冗余 ACK，它把这当做一种指示，说明 <strong>根在这个已被确认过3次的报文段之后的报文段已经丢失。</strong> 一旦收到 3 个冗余ACK，<strong>TCP就执行快速重传</strong>（fast retransmit）[RFC5681]，<u>即在该报文段的定时器过期之前上重传丢失的报文段。</u> 对于采用快速重传的TCP，可用下列代码片段代替 下图 中的 ACK时间：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511133200531.png" alt="image-20230511133200531" style="zoom: 80%;" />****</p>
<p><font color='red'><strong>快速重传算法</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511133751075.png" alt="image-20230511133751075" style="zoom:67%;" />

<p>TCP正确接收但失序的报文段是不会被接收方逐个确认的，TCP发送方仅需维持已发送过但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号(NextSeqNum)。</p>
<p>对TCP提出的一种修改意见是所谓的<strong>选择确认</strong>（Selective acknowledgment）[RFC 2018]，它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。</p>
<p>因此，TCP的差错恢复机制也许最好被分类为 GBN协议 与 SR协议的混合体。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>前面说过，一条 TCP 连接的每一侧主机都为该链接设置了 接收缓存。当该 TCP 连接收到正确、按序的字节后，他就将数据放入缓存中。<strong>相关联的 应用进程会从该缓存中读取数据，但 不必是数据刚一到达就立即读取。</strong> 事实上，接收方可能正忙于其他任务，甚至要过很长时间才去读取该数据。如果，某应用程序读取数据时 <strong>相对缓慢，</strong>而发送方发送得太多、太快， <strong>发送的数据就会很容易地使该链接的接收缓存溢出</strong></p>
<p>TCP为它的应用程序提供了 <strong>流量控制服务</strong>（flow-control service）以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。</p>
<p>前面提到过，TCP发方也可能因为IP网络的拥塞而被遏制；这种形式的发送方的控制被称为<strong>拥塞控制</strong>（congestion control），即使流量控制和拥塞控制采取的操作非常相似（对发送方的遏制），但是它们显然是针对完全不同的原因而采取的措施。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511134553625.png" alt="image-20230511134553625" style="zoom: 67%;" />

<p>TCP通过让发送方维护一个称为<strong>接收窗口</strong>（receive window）的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个指示 -&gt; 该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p>
<ul>
<li>接收方在其向发送方的<strong>TCP</strong>段头部的<strong>rwnd</strong>字段 “通告” 其空闲 buffer 大小<ul>
<li><strong>RcvBuffer</strong> 大小通过 socket 选项设置（典型默认大小为 4096 字节）</li>
<li>很多操作系统自动调整 <code>RcvBuffer</code></li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511134955233.png" alt="image-20230511134955233" style="zoom:67%;" />

 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511134924091.png" alt="image-20230511134924091" style="zoom:67%;" />

<ul>
<li>发送方限制未确认（”in-flight”）字节的个数 &lt;&#x3D; 接收方发过来的 <strong>rwnd</strong> 值 </li>
<li>保证接收方不会被淹没</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511135107936.png" alt="image-20230511135107936" style="zoom:67%;" />

<p>这个方案还存在一个小小的问题，假设主机B的接收缓存已经存满，使得 <code>rwnd=0</code> 。在将 <code>rwnd=0</code>通告给主机A之后，还要假设主机B没有任何数据要发给主机A。此时，考虑会发生什么情况。因为主机B上的应用进程将缓存清空，TCP并不向主机A发送带有<code>rwnd</code>新值的新报文段；事实上，TCP仅当在它有数据或有确认要发时才会发送报文段给主机A。这样，主机A不可能知道主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能再发送数据！为了解决这个问题，TCP规流中要求：<strong>当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。</strong></p>
<p>描述了 TCP 的流量控制服务之后，在此简要的 提一下 <strong>UDP 并不提供 流量控制，报文段由于缓存溢出可能在接收方丢失</strong>。 进程每次从 缓存中读取一个完整的报文段，如果 进程从缓存中读取报文段的速度还不够快，那么 <strong>缓存将会溢出，并且将丢失报文段</strong></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>在正式交换数据之前，发送方和接收方握手建立通信关系：</p>
<ul>
<li>同意建立连接（每一方到知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605151903646.png" alt="image-20230605151903646" style="zoom:67%;" />

<h4 id="同意建立连接"><a href="#同意建立连接" class="headerlink" title="同意建立连接"></a>同意建立连接</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152143277.png" alt="image-20230605152143277" style="zoom:50%;" />

<p><strong>Q：</strong>在网络中，2 次握手建立连接总是可行吗？</p>
<ul>
<li>变化的延迟（连接请求的段没有丢，但可能超时）</li>
<li>由于丢失造成的重传（e.g. req_conn(x)）</li>
<li>报文乱序</li>
<li>相互看不到对方</li>
</ul>
<p><font color='red'><strong>2次握手的失败场景：</strong></font></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152223254.png" alt="image-20230605152223254" style="zoom:67%;" />

<h4 id="TCP：3次握手"><a href="#TCP：3次握手" class="headerlink" title="TCP：3次握手"></a>TCP：3次握手</h4><p><strong>3次握手：</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152251379.png" alt="image-20230605152251379" style="zoom:67%;" />

<p><strong>3次握手解决：半连接和接收老数据问题</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152349112.png" alt="image-20230605152349112" style="zoom:67%;" />

<p><strong>TCP 3次握手：FSM</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152411715.png" alt="image-20230605152411715" style="zoom:67%;" />

<p>现在我们去更加仔细的观察如何建立 和 拆除一条 TCP 连接。</p>
<ul>
<li>第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部（参见图3-29)中的一个标志位(即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client_isn),并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。为了避免某些安全性攻击，在适当地随机化选择client_isn方面有着不少有趣的研究[CERT 2001-09]。</li>
<li>第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机（假定它的确到达了！),服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。（我们将在第8章看到，在完成三次握手的第三步之前分配这些缓存和变量，使得TCP易于受到称为SYN洪泛的拒绝服务攻击。）这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn+1。最后，服务器选择自己的初始序号(server_isn),并将其放置到TCP报文段首部的序号字段中。这个允许连接的报段实际上表明了：“我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn。”该允许连接的报文段被称为SYN ACK报文段（SYN ACK segment)。</li>
<li>第三步：在收到SYN ACK报文段后，客户也要给该连接分配缓存和变量。客户机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li>
</ul>
<p>一旦完成这三个步骤，客户和服务器主机就可以互相发送包括数据的 报文段 了。注意： <strong>为了创建这个连接，在两台主机之间发送了 3 个分组</strong>，由于这个原因，这种 连接创建过程 通常被称为 <strong>三次握手</strong></p>
<blockquote>
<p>TCP三次握手是用于建立一个可靠的TCP连接的过程，它包含以下三个步骤：</p>
<ol>
<li>发送方向接收方发送一个SYN报文段，请求建立连接。</li>
</ol>
<p>在这一步中，发送方向接收方发送一个SYN报文段，请求建立连接。这个SYN报文段中包含一个随机的序列号，用于标识数据流的起始位置。发送方还会向接收方发送一些其他的TCP参数，例如窗口大小、最大分段大小等等。</p>
<ol start="2">
<li>接收方向发送方发送一个SYN+ACK报文段，确认收到请求并请求建立连接。</li>
</ol>
<p>当接收方收到发送方的SYN报文段后，它向发送方发送一个SYN+ACK报文段，表示已经收到了建立连接的请求，并请求建立连接。这个SYN+ACK报文段中也包含一个随机的序列号，用于标识数据流的起始位置。接收方还会向发送方发送一些其他的TCP参数，例如窗口大小、最大分段大小等等。</p>
<ol start="3">
<li>发送方向接收方发送一个ACK报文段，确认收到确认消息并建立连接。</li>
</ol>
<p>当发送方收到接收方的SYN+ACK报文段后，它向接收方发送一个ACK报文段，表示已经收到了确认消息，并建立了连接。这个ACK报文段中包含接收方的序列号+1，用于告诉接收方下一次应该从哪个位置开始发送数据。</p>
<p>在这个过程中，发送方和接收方都会在自己的TCP缓存中保存一些用于维护连接状态的信息。这些信息包括序列号、窗口大小、最大分段大小等等，用于保证数据的可靠传输。</p>
<p>总之，TCP三次握手是用于建立一个可靠的TCP连接的过程，它包含三个步骤。在这个过程中，每一步都是非常重要的，它们确保了连接的正常建立，并保证了数据的完整性和可靠性。</p>
</blockquote>
<blockquote>
<p>如果没有TCP三次握手中的第三步，即接收方不向发送方发送确认消息，那么发送方将不知道接收方是否已准备好接收数据。在这种情况下，发送方可能会继续发送数据，但由于接收方未准备好接收数据，这些数据可能会丢失或损坏，从而导致通信失败。</p>
<p>因此，如果没有TCP三次握手中的第三步，通信的可靠性将无法得到保证，数据的传输将无法正确进行。这是TCP协议设计时必须考虑并解决的问题之一。</p>
</blockquote>
<h4 id="TCP：关闭连接"><a href="#TCP：关闭连接" class="headerlink" title="TCP：关闭连接"></a>TCP：关闭连接</h4><ul>
<li>客户端，服务器分别关闭它自己这一侧的连接<ul>
<li>发送 <strong>FIN bit &#x3D; 1</strong> 的 <strong>TCP片段</strong></li>
</ul>
</li>
<li>一旦接收到 <strong>FIN</strong>，用 <strong>ACK</strong>回应<ul>
<li>接到 <strong>FIN</strong>段，<strong>ACK</strong>可以和它自己发出的FIN段一起发送</li>
</ul>
</li>
<li>可以处理同时的<strong>FIN</strong>交换</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605152828888.png" alt="image-20230605152828888" style="zoom:67%;" />

<h5 id="TCP：关闭连接-1"><a href="#TCP：关闭连接-1" class="headerlink" title="TCP：关闭连接"></a>TCP：关闭连接</h5><p>任何一个都能终止该连接。当连接结束后主机中的“资源”（即缓存和变量）将被释放。</p>
<p>举一个例子，假设某客户打算关闭连接，如图3-40所示。客户应用进程发出一个关闭连接命令。这会引起<strong>客户TCP向服务器进程发送一个特殊的TCP报文段</strong>。这个特殊的报文段让其首部中的一个标志位即FIN比特（参见图3-29)被设置为1。当服务器接收到该报文段后，就<strong>向发送方回送一个确认报文段</strong>。然后，<strong>服务器发送它自己的终止报文段</strong>，其FIN比特被置为1。最后，<strong>该客户对这个服务器的终止报文段进行确认</strong>。此时，在两台主机上用于该连接的所有资源都被释放了。</p>
<p>可以注意到 上面客户端与服务器端一共有 <strong>4 次</strong> 动作，TCP 的连接关闭 也被称为 <strong>四次挥手</strong></p>
<blockquote>
<p>TCP四次挥手是用于关闭一个TCP连接的过程，它包含以下四个步骤：</p>
<ol>
<li>发送方向接收方发送一个FIN报文段，请求关闭连接。</li>
</ol>
<p>在这一步中，发送方向接收方发送一个FIN报文段，请求关闭连接。这个FIN报文段表示发送方已经不会再向接收方发送数据了。发送方也可以在这个报文段中携带一些最后的数据，以便接收方能够正确地处理这些数据。</p>
<ol start="2">
<li>接收方向发送方发送一个ACK报文段，确认收到关闭请求。</li>
</ol>
<p>当接收方收到发送方的FIN报文段后，它向发送方发送一个ACK报文段，表示已经收到了关闭请求。这个ACK报文段不会携带任何数据，只是用来确认发送方的关闭请求已经被接收到了。</p>
<ol start="3">
<li>接收方向发送方发送一个FIN报文段，请求关闭连接。</li>
</ol>
<p>在这一步中，接收方向发送方发送一个FIN报文段，请求关闭连接。这个FIN报文段表示接收方已经不会再向发送方发送数据了。接收方也可以在这个报文段中携带一些最后的数据，以便发送方能够正确地处理这些数据。</p>
<ol start="4">
<li>发送方向接收方发送一个ACK报文段，确认收到关闭请求。</li>
</ol>
<p>当发送方收到接收方的FIN报文段后，它向接收方发送一个ACK报文段，表示已经收到了关闭请求。这个ACK报文段不会携带任何数据，只是用来确认接收方的关闭请求已经被发送方接收到了。</p>
<p>在这个过程中，接收方向发送方发送的ACK报文段和FIN报文段可以合并在一起发送，即ACK+FIN报文段，这样就可以减少一次网络通信。但是，发送方向接收方发送的ACK报文段和FIN报文段需要分开发送，以避免接收方收到ACK报文段后就关闭了连接，导致发送方的FIN报文段无法到达接收方。</p>
<p>总之，TCP四次挥手是用于关闭一个TCP连接的过程，它包含四个步骤。在这个过程中，每一步都是非常重要的，它们确保了连接的正常关闭，并保证了数据的完整性和可靠性。</p>
<p>由于网络中存在一些延迟或丢失的数据包，因此在第四次挥手中，接收方还会向发送方发送一个最后的数据包，以确保数据能够完整地到达接收方。这个数据包可能是一个空数据包（ACK报文段），或者是一个包含数据的数据包（FIN+ACK报文段）。发送方接收到最后的数据包后，就可以确认通信已经结束，并释放连接。</p>
</blockquote>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞控制原理-1"><a href="#拥塞控制原理-1" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><p><font color='red'><strong>拥塞：</strong></font></p>
<ul>
<li>非正式的定义：“太多的数据需要网络传输，超过了<font color='red'>网络</font>的处理能力”</li>
<li>与流量控制不同</li>
<li>拥塞的表现：<ul>
<li>分组丢失（路由器缓冲区溢出）</li>
<li>分组经历比较长的延迟（在路由器的队列中排队）</li>
</ul>
</li>
<li>网络中前10位的问题！</li>
</ul>
<h3 id="拥塞的原因-x2F-代价"><a href="#拥塞的原因-x2F-代价" class="headerlink" title="拥塞的原因&#x2F;代价"></a>拥塞的原因&#x2F;代价</h3><h4 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605153208953.png" alt="image-20230605153208953" style="zoom:67%;" />

<h4 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605153358497.png" alt="image-20230605153358497" style="zoom: 67%;" />

<h4 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230511231510689.png" alt="image-20230511231510689" style="zoom: 67%;" />

<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>2 种常用的拥塞控制方法：</p>
<p><font color='red'><strong>端到端拥塞控制：</strong></font></p>
<ul>
<li>没有来自网络的显式反馈</li>
<li>段系统根据延迟和丢失时间推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p><font color='red'><strong>网络辅助的拥塞控制：</strong></font></p>
<ul>
<li>路由器提供给端系统以反馈信息<ul>
<li>单个 bit 置位，显式有拥塞（SNA，DEC bit，TCP&#x2F;IP ECN，ATM）</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
<h4 id="案例学习：ATM-ABR-拥塞控制"><a href="#案例学习：ATM-ABR-拥塞控制" class="headerlink" title="案例学习：ATM ABR 拥塞控制"></a>案例学习：ATM ABR 拥塞控制</h4><p><font color='red'><strong>ABR：available bit rate：</strong></font></p>
<ul>
<li>“弹性服务”</li>
<li>如果发送端的路径 “轻载”<ul>
<li>发送方使用可用带宽</li>
</ul>
</li>
<li>如果发送方的路径拥塞了<ul>
<li>发送方限制其发送的速度到一个最小保障速率上</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>RM（资源管理）信元：</strong></font></p>
<ul>
<li>有发送端发送，在数据信元中间隔插入</li>
<li><strong>RM</strong>信元中的比特被交换机设置（“网络辅助”）<ul>
<li><font color='cornflowerblue'>NI bit：</font>no increase in rate（轻微拥塞）速率不要增加了</li>
<li><font color='cornflowerblue'>CI bit：</font>congestion indication 拥塞指示</li>
</ul>
</li>
<li>发送端发送的 <strong>RM</strong> 信元被接收端返回，接收端不做任何改变</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605154744591.png" alt="image-20230605154744591" style="zoom:67%;" />

<ul>
<li>在 <strong>RM</strong> 信元中的 2 个字节 <strong>ER（explicit rate）</strong>字段<ul>
<li>拥塞的交换机可能会降低信元中 <strong>ER</strong> 的值</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
<li>数据信元中的 <strong>EFCI bit</strong>：被拥塞的交换机设置成1<ul>
<li>如果在管理信元 <strong>RM</strong> 前面的数据信元 <strong>EFCI</strong> 被设置成了 1，接收端在返回的 <strong>RM</strong> 信元中设置 <strong>CI bit</strong></li>
</ul>
</li>
</ul>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><h3 id="TCP-拥塞控制：机制"><a href="#TCP-拥塞控制：机制" class="headerlink" title="TCP 拥塞控制：机制"></a>TCP 拥塞控制：机制</h3><p><font color='red'><strong>端到端的拥塞控制机制</strong></font></p>
<ul>
<li>路由器不向主机有关拥塞 反馈信息<ul>
<li>路由器的负担较轻</li>
<li>符合网络核心简单的 <strong>TCP&#x2F;IP</strong> 架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</li>
</ul>
<p><font color='red'><strong>拥塞控制的几个问题：</strong></font></p>
<ul>
<li>如何检测拥塞<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略<ul>
<li>在拥塞发送时如何动作，降低速率<ul>
<li>轻微拥塞，如何降低</li>
<li>拥塞时，如何降低</li>
</ul>
</li>
<li>在拥塞缓解时如何动作，增加速率</li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：拥塞感知"><a href="#TCP-拥塞控制：拥塞感知" class="headerlink" title="TCP 拥塞控制：拥塞感知"></a>TCP 拥塞控制：拥塞感知</h3><p><font color='red'><strong>发送端如何探测到拥塞？</strong></font></p>
<ul>
<li>某个段超时了（丢失时间）：<strong>拥塞</strong><ul>
<li>超时时间到，某个段的确认没有来</li>
<li>原因1：网络<strong>拥塞</strong>（某个路由器缓冲区间没空间了，被丢弃）<font color='red'><strong>概率大</strong></font></li>
<li>原因2：<strong>出错被丢弃了</strong>（各级错误，没有通过校验，被丢弃）<font color='red'><strong>概率小</strong></font></li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
<li>有关某个段的 3 次重复 ACK：<strong>轻微拥塞</strong><ul>
<li>段的第 1 个 ACK，正常，确认绿段，期待红段</li>
<li>段的第 2 个重复 ACK，意味着红缎的后一段收到了，蓝段乱序到达</li>
<li>段的第 2、3、4个 ACK 重复，意味着红段的后第 2、3 、4 个段收到了，橙段乱序到达，同时红段丢失的可能性很大（后面 3 个段都到了，红段都没到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要必比第一种好</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230512154853892.png" alt="image-20230512154853892" style="zoom:67%;" />

<h3 id="TCP-拥塞控制：速率控制方法"><a href="#TCP-拥塞控制：速率控制方法" class="headerlink" title="TCP 拥塞控制：速率控制方法"></a>TCP 拥塞控制：速率控制方法</h3><p><font color='red'><strong>如何控制发送端发送的速率</strong></font></p>
<ul>
<li><p>维持一个拥塞窗口的值：<code>CongWin</code></p>
</li>
<li><p>发送端限制<font color='red'><strong>已发送但是未确认</strong></font>的数据量（的上限）：<code>LastByteSent-LastByteAcked &lt;= CongWin</code></p>
</li>
<li><p>从而粗略地控制发送方的往网络中注入的速率</p>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605160726492.png" alt="image-20230605160726492" style="zoom:67%;" />

<ul>
<li>CongWin 是动态的，是感知到的网络拥塞程度的函数<ul>
<li>超时或者3个重复ACK，CongWin<ul>
<li><strong>超时时：</strong>CongWin 降为 <strong>1 MSS</strong>（最大分段大小），进入SS阶段然后在倍增到<strong>CongWin&#x2F;2</strong>（每个RTT），从而进入CA阶段</li>
<li><strong>3个重复ACK</strong>：CongWin降为 CongWin&#x2F;2 ，CA阶段</li>
</ul>
</li>
<li>否则（正常收到ACK，没有发送以上情况）：CongWin跃跃欲试<ul>
<li><strong>SS阶段：加倍增加</strong>（每个RTT）</li>
<li><strong>CA阶段：线性阶段</strong>（每个RTT）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP拥塞控制和流量控制的联合动作"><a href="#TCP拥塞控制和流量控制的联合动作" class="headerlink" title="TCP拥塞控制和流量控制的联合动作"></a>TCP拥塞控制和流量控制的联合动作</h3><p><font color='red'><strong>联合控制的方法：</strong></font></p>
<ul>
<li>发送段控制 <strong>发送但是未确认</strong> 的量同时也不能够超过接收窗口，满足流量控制要求<ul>
<li>SendWin &#x3D; min{CongWin，RecvWin}</li>
<li>同时满足 <strong>拥塞控制</strong> 和 <strong>流量控制要求</strong></li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：策略概述"><a href="#TCP-拥塞控制：策略概述" class="headerlink" title="TCP 拥塞控制：策略概述"></a>TCP 拥塞控制：策略概述</h3><p><font color='red'><strong>拥塞控制策略：</strong></font></p>
<ul>
<li>慢启动</li>
<li>AIMD：线性增、乘性减</li>
<li>超时事件后的保守策略</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul>
<li><p>连接刚建立，<strong>CongWin &#x3D; 1  MSS</strong></p>
<ul>
<li>如：MSS &#x3D; 1460bytes &amp; RTT &#x3D; 200 msec</li>
<li>初始速率 &#x3D; 58.4 bps</li>
</ul>
</li>
<li><p>可用带宽可能 <strong>&gt;&gt;</strong> MSS&#x2F;RTT</p>
<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
</li>
<li><p>当连接开始时，指数性增加发送速率，直到发生丢失的事件</p>
</li>
<li><p>启动初值很低</p>
</li>
<li><p>但是速度很快</p>
</li>
<li><p>当连接开始时，指数型增加（每个RTT）发送速率直到发生丢失事件</p>
<ul>
<li>每一个RTT，ConWin 加倍</li>
<li>每收到一个 ACK 时，ConWin<strong>加1</strong> </li>
<li>慢启动阶段：只要不超时或 3 个重复ACK，一个 RTT，CongWin 加倍</li>
</ul>
</li>
<li><p><font color='red'><strong>总结：</strong></font>初始速率很慢，但是加速却是指数性的</p>
<ul>
<li>指数增加，SS时间很短，长期来看可以忽略</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605162347116.png" alt="image-20230605162347116" style="zoom:67%;" />

<h4 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h4><p><font color='red'><strong>乘性减：</strong></font></p>
<p>丢失事件后将CongWin降为1，将CongWin&#x2F;2 作为域值，进入慢启动阶段（倍增直到 CongWin&#x2F;2）</p>
<p><font color='red'><strong>加性增：</strong></font></p>
<p>当 CongWin &gt; 阈值时，一个 RTT 如没有发生丢失事件，将 ConWin 加 1 MSS：探测</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605162652186.png" alt="image-20230605162652186" style="zoom:67%;" />

<ul>
<li>当收到 <font color='red'>3个重复的ACK时：</font><ul>
<li>CongWin 减半</li>
<li>窗口（缓冲区大小）之后线性增长</li>
</ul>
</li>
<li>当<font color='red'>超时</font>事件发生时：<ul>
<li><strong>CongWin被设置成1 MSS，</strong>进入 SS 阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>思路</strong></font></p>
<ul>
<li>3 个重复的 ACK 表示网络还有一定的段传输能力</li>
<li>超时之前的 3 个重复的 ACK 表示 “警报“</li>
</ul>
<p><strong>改进</strong></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605163208030.png" alt="image-20230605163208030" style="zoom:67%;" />

<h3 id="总结：TCP拥塞控制"><a href="#总结：TCP拥塞控制" class="headerlink" title="总结：TCP拥塞控制"></a>总结：TCP拥塞控制</h3><ul>
<li>当CongWin &lt; Threshold,发送端处于慢启动阶段（slow-start),窗口指数性增长.</li>
<li>当CongWin &gt; Threshold,发送端处于拥塞避免阶段(congestion-avoidance),窗口线性增长.</li>
<li>当收到三个重复的ACKs(triple duplicate ACK)<ul>
<li>Threshold设置成CongWin&#x2F;2</li>
<li>CongWin&#x3D;Threshold+3.</li>
</ul>
</li>
<li>当超时事件发生时timeout,Threshold&#x3D;CongWin&#x2F;2 CongWin&#x3D;1 MSS,进入SS阶段</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230512161115322.png" alt="image-20230512161115322" style="zoom: 67%;" />

<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230512161132176.png" alt="image-20230512161132176"></p>
<h3 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h3><h4 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h4><ul>
<li>TCP的平均吞吐量是多少，使用窗口 window 尺寸 W 和 RTT 来描述？<ul>
<li>忽略慢启动阶段，假设发送端总有数据传输</li>
</ul>
</li>
<li>W：发生丢失事件时的窗口尺寸（单位：字节）<ul>
<li>平均窗口尺寸（#in-flight字节）：3&#x2F;4W</li>
<li>平均吞吐量：RTT时间吞吐 3&#x2F;4W</li>
</ul>
</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605163741560.png" alt="image-20230605163741560" style="zoom:67%;" />

<h4 id="TCP未来：TCP-over-“long-fat-pipes”"><a href="#TCP未来：TCP-over-“long-fat-pipes”" class="headerlink" title="TCP未来：TCP over “long, fat pipes”"></a>TCP未来：TCP over “long, fat pipes”</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605163819781.png" alt="image-20230605163819781" style="zoom:67%;" />

<h3 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h3><p><font color='red'><strong>公平性目标：</strong></font></p>
<p>如果 K 个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R&#x2F;K</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605163941790.png" alt="image-20230605163941790" style="zoom:67%;" />

<p><strong>为什么TCP是公平的？</strong></p>
<p>2个竞争的TCP会话：</p>
<ul>
<li>加性增，斜率为1，吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605164121134.png" alt="image-20230605164121134" style="zoom:67%;" />

<p><font color='red'><strong>公平性和UDP</strong></font></p>
<ul>
<li>多媒体应用通常不是用TCP<ul>
<li>应用发送的数据速率希望不受拥塞控制的节制</li>
</ul>
</li>
<li>使用UDP<ul>
<li>音视频应用泵出数据的速率是恒定的，忽略数据的丢失</li>
</ul>
</li>
<li>研究领域：TCP友好性</li>
</ul>
<p><font color='red'><strong>公平性和并行TCP连接</strong></font></p>
<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>Web浏览器</li>
<li>例如：带宽为R的链路支持了9个连接：<ul>
<li>如果新的应用要求建 1 个 TCP 连接，获得带宽 R&#x2F;10</li>
<li>如果新的应用要求建 11 个 TCP 连接，获得带宽 R&#x2F;2</li>
</ul>
</li>
</ul>
<h3 id="Explicit-Congestion-Notification（ECN）"><a href="#Explicit-Congestion-Notification（ECN）" class="headerlink" title="Explicit Congestion Notification（ECN）"></a>Explicit Congestion Notification（ECN）</h3><p><font color='red'><strong>网络辅助拥塞控制：</strong></font></p>
<ul>
<li>TOS字段中2个bit被网络路由器标记，用于指示是否发生拥塞</li>
<li>拥塞指示被传送到接收主机</li>
<li>在接收方-到发送方的ACK中，接收方（在IP数据报中看到了拥塞指示）设置 ECE bit，指示发送方发生了拥塞</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://typora8112.oss-cn-beijing.aliyuncs.com/typora-picture/image-20230605164801951.png" alt="image-20230605164801951" style="zoom:67%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>传输层提供的服务</p>
<ul>
<li>应用进程间的逻辑通信<ul>
<li>vs 网络层提供的是主机到主机的通信服务</li>
</ul>
</li>
<li>互联网上传输层协议：UDP TCP<ul>
<li>特性</li>
</ul>
</li>
</ul>
</li>
<li><p>多路复用和解复用</p>
<ul>
<li>端口：传输层的 <strong>SAP</strong></li>
<li>无连接的多路复用和解复用</li>
</ul>
</li>
<li><p>实例1：无连接传输层协议 UDP</p>
<ul>
<li>多路复用解复用</li>
<li>UDP报文格式</li>
<li>检错机制：校验和</li>
</ul>
</li>
<li><p>可靠数据传输原理</p>
<ul>
<li>问题描述</li>
<li>停止等待协议：<ul>
<li>rdt1.0 、rdt2.0、rdt2.1、rdt2.2、rdt3.0</li>
</ul>
</li>
<li>流水线协议<ul>
<li>GBN</li>
<li>SR</li>
</ul>
</li>
</ul>
</li>
<li><p>实例2：面向连接的传输层协议-TCP</p>
<ul>
<li>概述：TCP特性</li>
<li>报文段格式<ul>
<li>序号，超时机制及时间</li>
</ul>
</li>
<li>TCP可靠传输机制</li>
<li>重传，快速重传</li>
<li>流量控制</li>
<li>连接管理<ul>
<li>三次握手</li>
<li>对称连接释放</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞控制原理</p>
<ul>
<li>网络辅助的拥塞控制</li>
<li>端到端的拥塞控制</li>
</ul>
</li>
<li><p>TCP的拥塞控制</p>
<ul>
<li>AIMD</li>
<li>慢启动</li>
<li>超市之后的保守策略</li>
</ul>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://byxl8112.github.io">byxl8112</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://byxl8112.github.io/posts/CsOnline.html">https://byxl8112.github.io/posts/CsOnline.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://byxl8112.github.io" target="_blank">byxl8112</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cs/">Cs</a></div><div class="post_share"><div class="social-share" data-image="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/cs-online.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/money.jpg" target="_blank"><img class="post-qr-code-img" src="/img/money.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/spirngboot2.html"><img class="next-cover" src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/10-springboot2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot2</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/zzzw_8112/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221130105527.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">byxl8112</div><div class="author-info__description">有志者，事竟成</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" href="https://byxl8112.github.io"><i class="fab fa-home"></i><span>个人主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/byxl8112" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1662844460&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">兴趣爱好才是最大的动力，何不与我共同来攀知识高峰！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="toc-number">1.</span> <span class="toc-text">计算机网络和因特网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFInternet%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Internet？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%B7%E4%BD%93%E6%9E%84%E6%88%90%E8%A7%92%E5%BA%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">从具体构成角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E8%A7%92%E5%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">从服务角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">什么是协议？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">网络结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98"><span class="toc-number">1.3.</span> <span class="toc-text">网络边缘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E7%BD%91%E7%BB%9C%E8%AE%BE%E6%96%BD%E7%9A%84%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">采用网络设施的面向连接服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9A%84%E6%97%A0%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">采用基础设施的无连接服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="toc-number">1.4.</span> <span class="toc-text">网络核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">数据怎样通过网络进行传输？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">电路交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">分组交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2-1"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">分组交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">统计多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">网络核心的关键功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E5%BB%B6%E8%BF%9F%E5%92%8C%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">排队延迟和丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2-VS-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">电路交换 VS 分组交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.5.</span> <span class="toc-text">网络分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C%E5%92%8C%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93"><span class="toc-number">1.5.</span> <span class="toc-text">接入网络和物理媒体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="toc-number">1.5.1.</span> <span class="toc-text">接入网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8F%E5%AE%85%E6%8E%A5%E5%85%A5%EF%BC%9Amodem"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">住宅接入：modem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%94%A8%E6%88%B7%E7%BA%BF"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">数字用户线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%BC%86%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">线缆网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">家庭网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">企业接入网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">无线接入网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93"><span class="toc-number">1.5.2.</span> <span class="toc-text">物理媒体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E3%80%81%E5%85%89%E7%BA%A4"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">同轴电缆、光纤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">无线链路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Internet%E7%BB%93%E6%9E%84%E5%92%8CISP"><span class="toc-number">1.6.</span> <span class="toc-text">Internet结构和ISP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">1.6.1.</span> <span class="toc-text">互联网络结构：网络的网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#network-of-network"><span class="toc-number">1.6.2.</span> <span class="toc-text">network of network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISP%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">ISP之间的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">分组交换网中的时延、丢包和吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%88%86%E7%BB%84%E6%97%B6%E5%BB%B6"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">四种分组时延</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E5%BB%B6%E6%97%B6"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">排队延时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet%E7%9A%84%E5%BB%B6%E6%97%B6%E5%92%8C%E8%B7%AF%E7%94%B1"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">Internet的延时和路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">丢包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">吞吐量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E5%85%B6%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">协议层次及其服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">协议层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%82%B9"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">服务和服务访问点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">服务的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">服务和协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%EF%BC%88DU%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">数据单元（DU）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%A4%84%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.7.4.</span> <span class="toc-text">分层处理和实现复杂系统的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet-%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.7.5.</span> <span class="toc-text">Internet 协议栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISO-x2F-OSI-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.6.</span> <span class="toc-text">ISO&#x2F;OSI 参考模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%92%8C%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.7.</span> <span class="toc-text">封装和解封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E5%B1%82%E6%AC%A1%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83"><span class="toc-number">1.7.8.</span> <span class="toc-text">各层次的协议数据单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">应用层协议原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">网络应用的体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88C-x2F-S%EF%BC%89%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">客户-服务器（C&#x2F;S）体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E4%BD%93%EF%BC%88P2P%EF%BC%89%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">对等体（P2P）体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-x2F-S%E5%92%8CP2P%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%93"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">C&#x2F;S和P2P体系结构的混合体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">分布式进程通信需要解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A%E5%AF%B9%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%9D%80%EF%BC%88addressing%EF%BC%89"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">问题1：对进程进行编址（addressing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1-%E9%9C%80%E8%A6%81%E7%A9%BF%E8%BF%87%E5%B1%82%E9%97%B4%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">问题2：传输层提供的服务-需要穿过层间的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1-%E5%B1%82%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BB%A3%E8%A1%A8"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">问题2：传输层提供的服务-层间信息的代表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1-%E5%B1%82%E9%97%B4%E4%BF%A1%E6%81%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">问题2：传输层提供的服务-层间信息代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">问题3：如何使用 传输层提供的服务实现应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.4.</span> <span class="toc-text">应用层协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">运输服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">如何描述传输层的服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%AF%B9%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">常见应用对传输服务的要求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">Internet 传输层提供的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">TCP和UDP服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">UDP存在的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet-%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">Internet 应用及其应用层协议和传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8TCP%EF%BC%88SSL%EF%BC%89"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">安全TCP（SSL）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-and-HTTP"><span class="toc-number">2.2.</span> <span class="toc-text">Web and HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E4%B8%8E-HTTP"><span class="toc-number">2.2.1.</span> <span class="toc-text">Web 与 HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">2.2.2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%A6%82%E5%86%B5"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">HTTP概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">HTTP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85HTTP"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">持久HTTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">HTTP请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.2.4.1.</span> <span class="toc-text">通用格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.2.4.2.</span> <span class="toc-text">提交表单输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.4.3.</span> <span class="toc-text">方法类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">HTTP响应报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">HTTP响应状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%EF%BC%9Acookies"><span class="toc-number">2.2.3.</span> <span class="toc-text">用户-服务器状态：cookies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookies%EF%BC%9A%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">Cookies：维护状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookies%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">Cookies能带来什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E7%BC%93%E5%AD%98%EF%BC%88%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">Web缓存（代理服务器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">Web缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">缓存示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%8E%A5%E5%85%A5%E9%93%BE%E8%B7%AF"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">缓存示例：更快的接入链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">缓存示例：安装本地缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-1"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">缓存示例：安装本地缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6GET%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">条件GET方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FTP"><span class="toc-number">2.3.</span> <span class="toc-text">FTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FTP%EF%BC%9A%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">FTP：文件传输协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FTP%EF%BC%9A%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%88%86%E5%BC%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">FTP：控制连接与数据连接分开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FTP%E5%91%BD%E4%BB%A4%E3%80%81%E5%93%8D%E5%BA%94"><span class="toc-number">2.3.3.</span> <span class="toc-text">FTP命令、响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EMail"><span class="toc-number">2.4.</span> <span class="toc-text">EMail</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%EF%BC%88EMail%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">电子邮件（EMail）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EMail%EF%BC%9A%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">EMail：邮件服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMTP-RFC-2821"><span class="toc-number">2.4.3.</span> <span class="toc-text">SMTP  [RFC 2821]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9AAlice%E7%BB%99Bob%E5%8F%91%E9%80%81%E6%8A%A5%E6%96%87"><span class="toc-number">2.4.4.</span> <span class="toc-text">举例：Alice给Bob发送报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STMP%EF%BC%9A%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.5.</span> <span class="toc-text">STMP：总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.6.</span> <span class="toc-text">邮件报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9A%E5%A4%9A%E5%AA%92%E4%BD%93%E6%89%A9%E5%B1%95"><span class="toc-number">2.4.7.</span> <span class="toc-text">报文格式：多媒体扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.8.</span> <span class="toc-text">邮件访问协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POP3%E4%B8%8EIMAP"><span class="toc-number">2.4.9.</span> <span class="toc-text">POP3与IMAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POP3%EF%BC%88%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%89"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">POP3（本地管理文件夹）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMAP%EF%BC%88%E5%9B%A0%E7%89%B9%E7%BD%91%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">IMAP（因特网邮件访问协议）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">2.5.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%EF%BC%88Domain-Name-System%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">DNS（Domain Name System）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">DNS系统需要解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">2.5.3.</span> <span class="toc-text">DNS的历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">2.5.4.</span> <span class="toc-text">DNS总体思路和目标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">DNS的主要思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">DNS主要目的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9ADNS%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">2.5.5.</span> <span class="toc-text">问题1：DNS名字空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">DNS域名结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%EF%BC%9A%E6%A0%B9%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">DNS：根名字服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98-%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.5.6.</span> <span class="toc-text">问题2：解析问题-名字服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E5%8C%BA%E5%9F%9F%EF%BC%9AZone"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">名字空间划分为若干区域：Zone</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLD%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.5.7.</span> <span class="toc-text">TLD服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%B4%E6%8A%A4%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">区域名字服务器维护资源记录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87"><span class="toc-number">2.5.8.</span> <span class="toc-text">DNS记录和报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%A4%A7%E8%87%B4%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.9.</span> <span class="toc-text">DNS大致工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.5.10.</span> <span class="toc-text">名字服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Local-Name-Server%EF%BC%89"><span class="toc-number">2.5.10.1.</span> <span class="toc-text">本地名字服务器（Local Name Server）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Name-Server%EF%BC%89"><span class="toc-number">2.5.10.2.</span> <span class="toc-text">名字服务器（Name Server）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%BB%E6%9C%BA%E5%90%8D%E6%9F%A5%E8%AF%A2%E5%85%B6IP%E5%9C%B0%E5%9D%80"><span class="toc-number">2.5.11.</span> <span class="toc-text">通过主机名查询其IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.5.11.1.</span> <span class="toc-text">递归查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.5.11.2.</span> <span class="toc-text">迭代查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8A%A5%E6%96%87"><span class="toc-number">2.5.12.</span> <span class="toc-text">DNS协议、报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9A%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.13.</span> <span class="toc-text">提高性能：缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98%EF%BC%9A%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%9F%9F"><span class="toc-number">2.5.14.</span> <span class="toc-text">问题3：维护问题：新增一个域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BBDNS"><span class="toc-number">2.5.15.</span> <span class="toc-text">攻击DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DDOS%E6%94%BB%E5%87%BB"><span class="toc-number">2.5.15.1.</span> <span class="toc-text">DDOS攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB"><span class="toc-number">2.5.15.2.</span> <span class="toc-text">重定向攻击</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P2P%E5%BA%94%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">P2P应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AFP2P%E6%9E%B6%E6%9E%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">纯P2P架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91%EF%BC%9AC-x2F-S-vs-P2P"><span class="toc-number">2.6.2.</span> <span class="toc-text">文件分发：C&#x2F;S vs P2P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91%E6%97%B6%E9%97%B4%EF%BC%9AP2P%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">文件分发时间：P2P模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91%EF%BC%9ABitTorrent"><span class="toc-number">2.6.4.</span> <span class="toc-text">P2P文件分发：BitTorrent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BitTorrent%EF%BC%9A%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E5%9D%97"><span class="toc-number">2.6.5.</span> <span class="toc-text">BitTorrent：请求，发送文件块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">2.6.6.</span> <span class="toc-text">P2P文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P%EF%BC%9A%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9B%AE%E5%BD%95"><span class="toc-number">2.6.7.</span> <span class="toc-text">P2P：集中式目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%B4%AA%E6%B3%9B%EF%BC%9AGnutella"><span class="toc-number">2.6.8.</span> <span class="toc-text">查询洪泛：Gnutella</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gnutella%EF%BC%9A%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">Gnutella：协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gnutella%EF%BC%9A%E5%AF%B9%E7%AD%89%E6%96%B9%E5%8A%A0%E5%85%A5"><span class="toc-number">2.6.8.2.</span> <span class="toc-text">Gnutella：对等方加入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KaZaA"><span class="toc-number">2.6.9.</span> <span class="toc-text">KaZaA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8C%80%E7%A7%B0%E6%80%A7%EF%BC%9AKaZaA"><span class="toc-number">2.6.9.1.</span> <span class="toc-text">利用不匀称性：KaZaA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KaZaA%EF%BC%9A%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.6.9.2.</span> <span class="toc-text">KaZaA：查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KaZaA%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">2.6.9.3.</span> <span class="toc-text">KaZaA小技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributed-Hash-Table%EF%BC%88DHT%EF%BC%89"><span class="toc-number">2.6.10.</span> <span class="toc-text">Distributed Hash Table（DHT）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN"><span class="toc-number">2.7.</span> <span class="toc-text">CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%B5%81%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%92%8CCDN"><span class="toc-number">2.7.1.</span> <span class="toc-text">视频流化服务和CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%B5%81%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%92%8CCDN%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">视频流化服务和CDN：上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%9A%E8%A7%86%E9%A2%91"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">多媒体：视频</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E5%8C%96%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="toc-number">2.7.2.</span> <span class="toc-text">存储视频的流化服务：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E6%B5%81%E5%8C%96%E6%9C%8D%E5%8A%A1%EF%BC%9ADASH"><span class="toc-number">2.7.3.</span> <span class="toc-text">多媒体流化服务：DASH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF3%EF%BC%9ADASH"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">流式多媒体技术3：DASH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Content-Distribution-Networks-CDN"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">Content Distribution Networks (CDN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Content-Distribution-Networks%EF%BC%88CDNs%EF%BC%89"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">Content Distribution Networks（CDNs）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN%EF%BC%9A%E2%80%9C%E7%AE%80%E5%8D%95%E2%80%9D-%E5%86%85%E5%AE%B9%E8%AE%BF%E9%97%AE%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">CDN：“简单” 内容访问场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">TCP套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E7%BC%96%E7%A8%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">Socket编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-1"><span class="toc-number">2.8.2.</span> <span class="toc-text">TCP套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-2"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">TCP套接字编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-x2F-S-socket%E4%BA%A4%E4%BA%92%EF%BC%9ATCP"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">C&#x2F;S socket交互：TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-sockaddr-in"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">数据结构 sockaddr_in</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hostent"><span class="toc-number">2.8.2.4.</span> <span class="toc-text">数据结构 hostent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">2.8.2.5.</span> <span class="toc-text">例子：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="toc-number">2.9.</span> <span class="toc-text">UDP套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-Socket%E7%BC%96%E7%A8%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">UDP Socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-x2F-S-socket-%E4%BA%A4%E4%BA%92%EF%BC%9Audp"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">C&#x2F;S socket 交互：udp </span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">概述和传输层服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.1.</span> <span class="toc-text">传输服务器和协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-vs-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">3.1.2.</span> <span class="toc-text">传输层 vs 网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.3.</span> <span class="toc-text">Internet传输层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">多路复用与解复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">多路解复用工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%EF%BC%88UDP%EF%BC%89%E5%A4%9A%E8%B7%AF%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">无连接（UDP）多路解复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">面向连接（TCP）的多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb-Server"><span class="toc-number">3.2.4.</span> <span class="toc-text">面向连接的多路复用：多线程Web Server</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%EF%BC%9AUDP"><span class="toc-number">3.3.</span> <span class="toc-text">无连接传输：UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">UDP：用户数据报协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">UDP校验和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">Internet校验和的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">可靠数据传输的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88rdt%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">可靠数据传输（rdt）的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">可靠数据传输：问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt1-0-%EF%BC%9A%E5%9C%A8%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.4.3.</span> <span class="toc-text">rdt1.0  ：在可靠信道上的可靠数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2-0"><span class="toc-number">3.4.4.</span> <span class="toc-text">rdt2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-0-%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">rdt2.0: 具有比特差错的信道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FSM%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">FSM描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%B7%AE%E9%94%99%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">没有差错时的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%B7%AE%E9%94%99%E6%97%B6"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">有差错时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2-1-%EF%BC%9A%E5%A4%84%E7%90%86%E5%87%BA%E9%94%99%E7%9A%84ACK-x2F-NAK"><span class="toc-number">3.4.5.</span> <span class="toc-text">rdt2.1 ：处理出错的ACK&#x2F;NAK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-0-%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7%EF%BC%81-gt-rdt-2-1"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">rdt2.0 的致命缺陷！ -&gt; rdt 2.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1-%E5%8F%91%E9%80%81%E6%96%B9%E5%A4%84%E7%90%86%E5%87%BA%E9%94%99%E7%9A%84ACK-x2F-NAK"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">rdt2.1 : 发送方处理出错的ACK&#x2F;NAK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1-%EF%BC%9A%E6%8E%A5%E6%94%B6%E6%96%B9%E5%A4%84%E7%90%86%E5%87%BA%E9%94%99%E7%9A%84ACK-x2F-NAK"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">rdt2.1 ：接收方处理出错的ACK&#x2F;NAK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1-%EF%BC%9A%E8%AE%A8%E8%AE%BA"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">rdt2.1 ：讨论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-1%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">3.4.5.5.</span> <span class="toc-text">rdt2.1的运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2-2-%EF%BC%9A%E6%97%A0NAK%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.6.</span> <span class="toc-text">rdt2.2 ：无NAK的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-2-%EF%BC%9A%E6%97%A0NAK%E7%9A%84%E5%8D%8F%E8%AE%AE-1"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">rdt2.2 ：无NAK的协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-2%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">rdt2.2的运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt2-2-%EF%BC%9A%E5%8F%91%E9%80%81%E6%96%B9%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E7%89%87%E6%96%AD"><span class="toc-number">3.4.6.3.</span> <span class="toc-text">rdt2.2 ：发送方和接收方片断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt3-0-%EF%BC%9A%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">3.4.7.</span> <span class="toc-text">rdt3.0 ：具有比特差错和分组丢失的信道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0%EF%BC%9A%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">3.4.7.1.</span> <span class="toc-text">rdt3.0：具有比特差错和分组丢失的信道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0-%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-number">3.4.7.2.</span> <span class="toc-text">rdt3.0 发送方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0-%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">3.4.7.3.</span> <span class="toc-text">rdt3.0 的运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">3.4.7.4.</span> <span class="toc-text">rdt3.0的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt3-0-%EF%BC%9A%E5%81%9C-%E7%AD%89%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.7.5.</span> <span class="toc-text">rdt3.0 ：停-等操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%9A%E6%8F%90%E9%AB%98%E9%93%BE%E8%B7%AF%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">3.4.8.</span> <span class="toc-text">流水线：提高链路利用率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.8.1.</span> <span class="toc-text">流水线协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88slide-window%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.9.</span> <span class="toc-text">通用：滑动窗口（slide window）协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E8%BF%87%E7%A8%8B-%E7%9B%B8%E5%AF%B9%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">发送窗口滑动过程 - 相对表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88slide-window%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.9.2.</span> <span class="toc-text">滑动窗口（slide window）协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8-gt-%E5%89%8D%E6%B2%BF%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.4.9.3.</span> <span class="toc-text">发送窗口的移动 -&gt; 前沿移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8-gt-%E5%90%8E%E6%B2%BF%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.4.9.4.</span> <span class="toc-text">发送窗口的移动 -&gt; 后沿移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="toc-number">3.4.9.5.</span> <span class="toc-text">滑动窗口协议-发送窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE-%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3"><span class="toc-number">3.4.9.6.</span> <span class="toc-text">滑动窗口协议-接收窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8"><span class="toc-number">3.4.10.</span> <span class="toc-text">窗口互动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%842%E4%B8%AA%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8"><span class="toc-number">3.4.10.1.</span> <span class="toc-text">正常情况下的2个窗口互动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8BGBN%E7%9A%842%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8"><span class="toc-number">3.4.10.2.</span> <span class="toc-text">异常情况下GBN的2窗口互动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8BSR%E7%9A%842%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8"><span class="toc-number">3.4.10.3.</span> <span class="toc-text">异常情况下SR的2窗口互动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%EF%BC%9A%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.11.</span> <span class="toc-text">流水线协议：总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GBN%E5%92%8CSR"><span class="toc-number">3.4.11.1.</span> <span class="toc-text">GBN和SR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GBN%EF%BC%9A%E6%89%A9%E5%B1%95%E7%9A%84FSM"><span class="toc-number">3.4.11.2.</span> <span class="toc-text">GBN：扩展的FSM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0SR"><span class="toc-number">3.4.11.3.</span> <span class="toc-text">选择重传SR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GBN%E5%8D%8F%E8%AE%AE%E5%92%8CSR%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.4.12.</span> <span class="toc-text">GBN协议和SR协议的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.4.12.1.</span> <span class="toc-text">相同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.4.12.2.</span> <span class="toc-text">不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94GBN%E5%92%8CSR"><span class="toc-number">3.4.12.3.</span> <span class="toc-text">对比GBN和SR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B0%BA%E5%AF%B8"><span class="toc-number">3.4.12.4.</span> <span class="toc-text">窗口的最大尺寸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.13.</span> <span class="toc-text">可靠数据传输机制及其用途的总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP"><span class="toc-number">3.5.</span> <span class="toc-text">面向连接的传输：TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">TCP：概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.2.</span> <span class="toc-text">TCP报文段结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84-1"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">TCP报文段结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%BA%8F%E5%8F%B7%EF%BC%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">TCP序号，确认号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%BE%80%E8%BF%94%E5%BB%B6%E6%97%B6%EF%BC%88RTT%EF%BC%89%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">TCP往返延时（RTT）和超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.5.3.</span> <span class="toc-text">TCP：可靠数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-1"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">TCP：可靠数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%91%E9%80%81%E6%96%B9%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">TCP 发送方（简化版）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8F%91%E9%80%81%E6%96%B9%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">TCP发送方事件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%EF%BC%9A%E9%87%8D%E4%BC%A0"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">TCP：重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">3.5.3.5.</span> <span class="toc-text">TCP快速重传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.5.4.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.5.</span> <span class="toc-text">连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">TCP连接管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%84%8F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">同意建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%EF%BC%9A3%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">TCP：3次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%EF%BC%9A%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.5.4.</span> <span class="toc-text">TCP：关闭连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%EF%BC%9A%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5-1"><span class="toc-number">3.5.5.4.1.</span> <span class="toc-text">TCP：关闭连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">拥塞控制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">拥塞控制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%9A%84%E5%8E%9F%E5%9B%A0-x2F-%E4%BB%A3%E4%BB%B7"><span class="toc-number">3.6.2.</span> <span class="toc-text">拥塞的原因&#x2F;代价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">场景1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">场景2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">场景3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">拥塞控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0%EF%BC%9AATM-ABR-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">案例学习：ATM ABR 拥塞控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.</span> <span class="toc-text">TCP 拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">TCP 拥塞控制：机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%8B%A5%E5%A1%9E%E6%84%9F%E7%9F%A5"><span class="toc-number">3.7.2.</span> <span class="toc-text">TCP 拥塞控制：拥塞感知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E9%80%9F%E7%8E%87%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.3.</span> <span class="toc-text">TCP 拥塞控制：速率控制方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E8%81%94%E5%90%88%E5%8A%A8%E4%BD%9C"><span class="toc-number">3.7.4.</span> <span class="toc-text">TCP拥塞控制和流量控制的联合动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0"><span class="toc-number">3.7.5.</span> <span class="toc-text">TCP 拥塞控制：策略概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIMD"><span class="toc-number">3.7.5.2.</span> <span class="toc-text">AIMD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9ATCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.6.</span> <span class="toc-text">总结：TCP拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">3.7.7.</span> <span class="toc-text">TCP 吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">3.7.7.1.</span> <span class="toc-text">TCP吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%9C%AA%E6%9D%A5%EF%BC%9ATCP-over-%E2%80%9Clong-fat-pipes%E2%80%9D"><span class="toc-number">3.7.7.2.</span> <span class="toc-text">TCP未来：TCP over “long, fat pipes”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="toc-number">3.7.8.</span> <span class="toc-text">TCP 公平性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Explicit-Congestion-Notification%EF%BC%88ECN%EF%BC%89"><span class="toc-number">3.7.9.</span> <span class="toc-text">Explicit Congestion Notification（ECN）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">网络层</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/CsOnline.html" title="计算机网络"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/cs-online.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/posts/CsOnline.html" title="计算机网络">计算机网络</a><time datetime="2023-05-29T00:25:16.000Z" title="发表于 2023-05-29 08:25:16">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/spirngboot2.html" title="SpringBoot2"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/10-springboot2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot2"/></a><div class="content"><a class="title" href="/posts/spirngboot2.html" title="SpringBoot2">SpringBoot2</a><time datetime="2023-05-28T12:50:28.000Z" title="发表于 2023-05-28 20:50:28">2023-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/springMVC.html" title="SpringMVC"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/09-SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"/></a><div class="content"><a class="title" href="/posts/springMVC.html" title="SpringMVC">SpringMVC</a><time datetime="2023-05-27T12:10:42.000Z" title="发表于 2023-05-27 20:10:42">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/spring6.html" title="Spring6"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/08-Spring.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring6"/></a><div class="content"><a class="title" href="/posts/spring6.html" title="Spring6">Spring6</a><time datetime="2023-05-02T02:13:35.000Z" title="发表于 2023-05-02 10:13:35">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7.html" title="MyBatis"><img src="https://typora8112.oss-cn-beijing.aliyuncs.com/byxl8112-pictures/07-MyBatis.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/posts/7.html" title="MyBatis">MyBatis</a><time datetime="2023-04-23T13:08:35.000Z" title="发表于 2023-04-23 21:08:35">2023-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> byxl8112</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><<head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-liang-production.up.railway.app',
      region: 'ap-shanghai',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-liang-production.up.railway.app',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo@1/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer data-pjax type="text/javascript" src="https://npm.elemecdn.com/xianqi-hexo/js/animate.js"></script><div class="aplayer no-destroy" data-id="2358838077" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="false" muted></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/null.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#posts-chart","#tags-chart","#categories-chart",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":160,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>